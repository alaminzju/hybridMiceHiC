#!/usr/bin/env perl
#===============================================================================
#
#      COMPANY:  Group of Epigenome Biology, PICB
#      VERSION:  1.0
#      CREATED:  2016年8月21日 15时42分31秒
#     REVISION:  ---
#===============================================================================

use strict;
use warnings;
use Getopt::Long;
use POSIX qw(strftime);
use Cwd;
use Parallel::ForkManager;
use List::Util qw(sum);
use List::MoreUtils qw(pairwise);


my %opts = (
    output      => 'HiC-output',    # top-level output directory
    cpu         => 20,              # total number of CPUs
    mismatch    => 1,               # mismatches allowed for mapping
    taglen      => 40,              # tag length for mapping
    selflen     => 500,             # self-ligation distance
#    distance    => 500,             # maximun distance to fragments ends
    trim5       => 0,               # trim 5 prime bp before mapping
    trim3       => 0,               # trim 3 prime bp before mapping
    lenstep     => 10,              # truncating length for iterative mapping
    binsize     => 20_000,          # genome bin size
    maxlines    => 1_000_000,       # for controlling memory usage, lines cutoff
                                    # 1M lines costs ~500M memory
);

my @ARGV_backup = @ARGV;
GetOptions(
    \%opts,
    'fq=s',             # input fastq files directory
    'input|i=s',
    'output|o=s',
    'genome|g=s',       # reference name, hg19, mm9 ...
    'cpu|c=i',
    'chr=s',
    'mismatch|mm=i',
    'taglen|tl=i',
    'selflen|sl=i',     # self-ligation distance, used when enzyme is not set
    'trim5|5=i',
    'trim3|3=i',
    'lenstep|ls=i',
    'maxlines|ml=i',
    # options for enzyme filtering
    'enzyme|ez=s',      # enzyme name, if set, using RE fragments filtering PETs
    'fragments|fm=s',   # fragments file for enzyme, either one works the same
    'distance|di=i',     # maximun distance to fragments ends
    # options for makeGenomicMatrix
    'binsize|bs=i',
    'rawmatrix|rm=s',   # genome matrix file name
    # options for ICEnorm
    'icematrix|im=s',   # --results_filename
    'lowpec|lp=f',      # --filter_low_counts_perc
    'highpec|hp=f',     # --filter_high_counts_perc
    'eps=f',            # --eps
    'maxiter|mi=i',     # --max_iter
    'dense',            # --dense
    # options for genomicMatrixToWashU
    'regionbed|rb=s',
    'bgzip|bz',
    'counts=i',
    # options for petsToWashU
    'maxdistance|md=i',
    'background|bg=i',
    # options for calcIntraMatrixPCC
    'd1=s',
    'd2=s',
    # options for calcIntraMatrixPCC
    'cutoff|co=f',
    # options for callInteractions
    'regionsize|rs=i',
    'minpts|mp=i',
    # options for diffCompartments
    'windowsize|ws=i',
    'gapsize|gs=i',
    'foldchange|fc=f',
    'factor=f',
    'sample1|s1=s',
    'sample2|s2=s',
    # options for getInteractedGenes and annotateInteractions
    'upstream|us=i',
    'downstream|ds=i',
    'intra=s',
    'inter=s',
    'gene|ge=s',
    'ratio|rt=f',
    'length|lt=i',
    'single|sg',       # single annotate
    'annotation|n=s',
    'type=s',
    'merge|mg',
    'boundarySize=i',
    'help|h',
) or die "Parse options failed!\n";


_printUsage() unless @ARGV_backup;

# check help information here
my $function = shift @ARGV;
if ($function) {
    my @allFunctions = qw(
        mapping pairing splitAndRemoveDup
        makeREfragments mapPETsToFragments supportedEnzymes
        removeShortLigation
        makeGenomicMatrix ICEnorm genomicMatrixToWashU
        petsToWashU chrPetsToWashU
        makeIntraMatrix makeInterMatrix calcIntraMatrixPCC
        callInteractions annotateInteractions interactionsToWashU
        parseAnnotate getInteractedGenes selectInteractions
        intraTxtToBed
        compartment pcatobedgraph diffCompartments checkABcompartments
        calcDomainIndexes callDIdomains
        calcInsulationScores callInsulationTADs insulationMatrix
    );
    my @match = grep {/^$function/i} @allFunctions;
    if ( @match > 1) {
        print "Multiple functions found for '$function'!\n";
        die "Please choose one of: @match\n";
    }
    elsif ( not @match ) {
        die "Unknown function '$function' called!\n";
    }
    $opts{help} = 1 if @ARGV_backup == 1; # only function is given
    if ( $opts{help} ) {    # help on specific function
        if ( 'mapping' =~ /^$function/i  ) {
            mapping_docs();
        }
        elsif ( 'pairing' =~ /^$function/i  ) {
            pairing_docs();
        }
        elsif ( 'splitAndRemoveDup' =~ /^$function/i  ) {
            splitAndRemoveDup_docs();
        }
        elsif ( 'makeREfragments' =~ /^$function/i  ) {
            makeREfragments_docs();
        }
        elsif ( 'mapPETsToFragments' =~ /^$function/i  ) {
            mapPETsToFragments_docs();
        }
        elsif ( 'removeShortLigation' =~ /^$function/i  ) {
            removeShortLigation_docs();
        }
        elsif ( 'supportedEnzymes' =~ /^$function/i  ) {
            supportedEnzymes_docs();
        }
        elsif ( 'makeGenomicMatrix' =~ /^$function/i  ) {
            makeGenomicMatrix_docs();
        }
        elsif ( 'ICEnorm' =~ /^$function/i  ) {
            ICEnorm_docs();
        }
        elsif ( 'genomicMatrixToWashU' =~ /^$function/i  ) {
            genomicMatrixToWashU_docs();
        }
        elsif ( 'calcDomainIndexes' =~ /^$function/i  ) {
            calcDomainIndexes_docs();
        }
        elsif ( 'petsToWashU' =~ /^$function/i  ) {
            petsToWashU_docs();
        }
        elsif ( 'chrPetsToWashU' =~ /^$function/i  ) {
            chrPetsToWashU_docs();
        }
        elsif ( 'makeIntraMatrix' =~ /^$function/i  ) {
            makeIntraMatrix_docs();
        }
        elsif ( 'makeInterMatrix' =~ /^$function/i  ) {
            makeInterMatrix_docs();
        }
        elsif ( 'calcIntraMatrixPCC' =~ /^$function/i  ) {
            calcIntraMatrixPCC_docs();
        }
        elsif ( 'compartment' =~ /^$function/i ) {
            compartment_docs();
        }
        elsif ( 'pcatobedgraph' =~ /^$function/i ) {
            pcatobedgraph_docs();
        }
        elsif ( 'filterpets' =~ /^$function/i ) {
            filterpets_docs();
        }
        elsif ( 'diffCompartments' =~ /^$function/i  ) {
            diffCompartments_docs();
        }
        elsif ( 'callInteractions' =~ /^$function/i  ) {
            callInteractions_docs();
        }
        elsif ( 'annotateInteractions' =~ /^$function/i  ) {
            annotateInteractions_docs();
        }
        elsif ( 'parseAnnotate' =~ /^$function/i ) {
            parseAnnotate_docs();
        }
        elsif ( 'getInteractedGenes' =~ /^$function/i  ) {
            getInteractedGenes_docs();
        }
        elsif ( 'selectInteractions' =~ /^$function/i  ) {
            selectInteractions_docs();
        }
        elsif ( 'interactionsToWashU' =~ /^$function/i  ) {
            interactionsToWashU_docs();
        }
        elsif ( 'intraTxtToBed' =~ /^$function/i  ) {
            intraTxtToBed_docs();
        }
        elsif ( 'callDIdomains' =~ /^$function/i  ) {
            callDIdomains_docs();
        }
        elsif ( 'insulationMatrix' =~ /^$function/i  ) {
            insulationMatrix_docs();
        }
        elsif ( 'checkABcompartments' =~ /^$function/i  ) {
            checkABcompartments_docs();
        }
        elsif ( 'calcInsulationScores' =~ /^$function/i  ) {
            calcInsulationScores_docs();
        }
        elsif ( 'callInsulationTADs' =~ /^$function/i  ) {
            callInsulationTADs_docs();
        }
    }
}
else {
    _printUsage() if $opts{help};
}

# global variables definition
my ($genome, $chromSizesFile, @chrs, %chrs);
my $cpu = $opts{cpu};
my $cwd = cwd();
my $cutoff = $opts{maxlines}; # line number cutoff




# functions calling here
if    ( 'mapping' =~ /^$function/i  ) {
    die "-fq, -output and -genome are needed!\n"
        unless $opts{fq} and $opts{genome} and $opts{output};
    _getGenomeInfo();
    my $fqDir = $opts{fq};
    my $output = $opts{output};
    $output = "$cwd/$output" unless $output =~ /^\//;
    $fqDir = "$cwd/$fqDir" unless $fqDir =~ '^\/'; # absolute path
    _logging("Searching for fastq files under '$fqDir'.");
    my %fqPEfiles = %{ _searchFqFiles($fqDir) };   # prefix => {R1, R2}
    my $mapDir    = "$output/map";
    my $petDir    = "$output/pets";
    mkdir $output unless -d $output;
    mkdir $mapDir unless -d $mapDir;
    mkdir $petDir unless -d $petDir; # not used, but generate it
    chdir $mapDir or die "Can't chdir to $mapDir. $!\n";
    my $prefix = (keys %fqPEfiles)[0];
    my $readsLength = _getReadsLength("$fqDir/$fqPEfiles{$prefix}{R1}");
    _logging("Detected raw reads length is $readsLength.");
    _logging("Mapping reads to reference $genome.");
    my $trim5    = $opts{trim5};
    my $trim3    = $opts{trim3};
    $readsLength = $readsLength - $trim5 - $trim3; # trimmed before mapping
    my $totalReads = _iterativeMapping($fqDir, $readsLength, \%fqPEfiles);
    _summaryIterativeResult($totalReads);
}
elsif ( 'pairing' =~ /^$function/i  ) {
    die "-output and -genome are needed!\n"
        unless $opts{genome} and $opts{output};
    _getGenomeInfo();
    my $mapDir = "$opts{output}/map";
    chdir $mapDir or die "Can't chdir to $mapDir. $!\n";
    my $tmpDir = "tmp.$$";
    mkdir $tmpDir unless -d $tmpDir;
    my %parts;    # part indexes
    my $pm = Parallel::ForkManager->new( $cpu, $tmpDir );
    $pm->run_on_finish(
        sub {
            my ( $pid, $exit_code, $indent, $exit_signal, $core_dump,
                $data_ref ) = @_;
            die "Failed to process mapped tags for '$indent.hits.txt'.\n"
              unless $exit_code == 0;
            for (@$data_ref) {    # $data_ref is an array reference
                $parts{$_} = undef;
            }
        }
    );
    _logging("Split mapped tags for pairing.");
    for my $type (qw(R1 R2)) {
        $pm->start($type) and next;
        my @parts = _splitMapped($type);
        $pm->finish(0, \@parts);
    }
    $pm->wait_all_children;
    my $pairedPETs;    # number of paired PETs for each $prefix
    $pm->run_on_finish(
        sub {
            my ( $pid, $exit_code, $indent, $exit_signal, $core_dump,
                $data_ref ) = @_;
            die "Failed to pairing PETs for R*.part.$indent'.\n"
              unless $exit_code == 0;
            $pairedPETs += $$data_ref;    # $data_ref is an scalar reference
        }
    );
    _logging("Pairing mapped tags.");
    for my $part (keys %parts) {
        $pm->start("$part") and next;
        my $pairedPETs = _pairing( $part );
        $pm->finish( 0, \$pairedPETs );
    }
    $pm->wait_all_children;
    rmdir $tmpDir or warn "Can't delete folder $tmpDir. $!\n";
    unlink 'paired.txt' if -e 'paired.txt';
    for my $part (keys %parts) {
        next unless -e "paired.part.$part";
        system("cat paired.part.$part >> paired.txt") == 0
          or die
          "CMD: cat paired.part.$part >> paired.txt failed. $!\n";
        unlink "paired.part.$part";
    }
    _logging("Totally paired $pairedPETs PETs.");
}
elsif ( 'splitAndRemoveDup' =~ /^$function/i  ) {
    die "-output and -genome are needed!\n"
        unless $opts{genome} and $opts{output};
    _getGenomeInfo();
    my $mapDir = "$opts{output}/map";
    chdir $mapDir or die "Can't chdir to $mapDir. $!\n";
    _logging("Split paired PETs into chrs and remove redundance.");
    _splitAndRemoveDup( 'paired.txt' );

}
elsif ( 'mapPETsToFragments' =~ /^$function/i  ) {
    die "-output and -genome are needed!\n"
        unless $opts{genome} and $opts{output};
    _getGenomeInfo();
    die "One of -enzyme and -fragments is NEEDED!\n"
        unless ($opts{enzyme} or $opts{fragments});
    my $output = $opts{output};
    $output = "$cwd/$output" unless $output =~ /^\//;
    my $dir = "$output/pets";
    mkdir $dir unless -d $dir;
    chdir "$output/map" or die "Can't chdir to $output/map. $!\n";
    if ($opts{fragments}) {
        $opts{fragments} = "$cwd/$opts{fragments}"
            unless $opts{fragments} =~ /^\//;
    }
    else {
        _logging("Check enzyme and make RE fragments.");
        _checkEnzyme();
        _makeREfragments();
    }
    _logging("Filter paired PETs using RE fragments.");
    _mapPETsToFragments($dir);
}
elsif ( 'makeREfragments' =~ /^$function/i  ) {
    die "-genome and -enzyme are NEEDED!\n" unless $opts{enzyme} and $opts{genome};
    _getGenomeInfo();
    _logging("Check enzyme and make RE fragments.");
    _checkEnzyme();
    _makeREfragments();
}
elsif ( 'removeShortLigation' =~ /^$function/i  ) {
    die "-output and -genome are needed!\n"
        unless $opts{genome} and $opts{output};
    _getGenomeInfo();
    my $output = $opts{output};
    $output = "$cwd/$output" unless $output =~ /^\//;
    my $dir = "$output/pets";
    mkdir $dir unless -d $dir;
    chdir "$output/map" or die "Can't chdir to $output/map. $!\n";
    _removeSelfLigation($dir);
}
elsif ( 'supportedEnzymes' =~ /^$function/i  ) {
    _supportedEnzymes();
}
elsif ( 'makeGenomicMatrix' =~ /^$function/i  ) {
    die "-output and -genome are needed!\n"
        unless $opts{genome} and $opts{output};
    _getGenomeInfo();
    my $dir = "$opts{output}/pets";
    chdir $dir or die "Can't chdir to $dir. $!\n";
    my $rawmatrix;
    if ($opts{rawmatrix}) {
        $rawmatrix = $opts{rawmatrix};
    }
    else {
         $rawmatrix = "genomeBins." . int($opts{binsize} / 1_000) . "kb.matrix";
    }
    (my $binsFile = $rawmatrix) =~ s/matrix$/bed/;
    _makeGenomeBins($binsFile);
    _makeGenomicMatrix($rawmatrix);
}
elsif ( 'ICEnorm' =~ /^$function/i  ) {
    die "At least -rawmatrix is needed for ICEnorm!\n" unless $opts{rawmatrix};
    my $dir = "$opts{output}/pets";
    chdir $dir or die "Can't chdir to $dir. $!\n";
    my $rawmatrix = $opts{rawmatrix};
    my $icematrix;
    if ($opts{icematrix}) {
        $icematrix = $opts{icematrix};
    }
    else {
        ($icematrix = $rawmatrix) =~ s/matrix$/iced.matrix/;
    }
    _iceNormalization($rawmatrix, $icematrix);
}
elsif ( 'genomicMatrixToWashU' =~ /^$function/i  ) {
    die "-rawmatrix, -regionbed and -output are needed.\n"
        unless $opts{rawmatrix} and $opts{regionbed} and $opts{output};
    $opts{maxdistance} = 3_000_000 unless defined $opts{maxdistance};
    $opts{counts} = 10_000_000 unless defined $opts{counts};
    _genomicMatrixToWashU();
}
elsif ( 'calcDomainIndexes' =~ /^$function/i ) {
    die "At least -genome and -output are needed!\n"
        unless $opts{genome} and $opts{output};
    $opts{maxdistance} = $opts{maxdistance} || 2_000_000;
    $opts{binsize} = $opts{binsize} || 20_000;
    _getGenomeInfo();
    _calcDomainIndexes(@opts{qw(binsize maxdistance output)});
}
elsif ( 'petsToWashU' =~ /^$function/i ) {
    die "At least -genome and -output are needed!\n"
        unless $opts{genome} and $opts{output};
    _getGenomeInfo();
    unless (defined($opts{maxdistance}) and $opts{maxdistance} == 0) {
        $opts{maxdistance}  = $opts{maxdistance} || 2_000_000;
    }
    _petsToWashU(@opts{qw(binsize maxdistance output background)});
    _bgzipFile($opts{output});
}
elsif ( 'chrPetsToWashU' =~ /^$function/i ) {
    die "At least -chr, -genome and -output are needed!\n"
        unless $opts{chr} and $opts{genome} and $opts{output};
    _getGenomeInfo();
    if (defined($opts{maxdistance}) and $opts{maxdistance} == 0) {
        $opts{maxdistance} = $chrs{$opts{chr}};
    }
    else {
        $opts{maxdistance}  = $opts{maxdistance} || 2_000_000;
    }
    _petsToWashUChr(@opts{qw(chr binsize maxdistance output background)});
    _bgzipFile($opts{output});
}
elsif ( 'makeIntraMatrix' =~ /^$function/i ) {
    die "At least -genome and -output are needed!\n"
        unless $opts{genome} and $opts{output};
    mkdir $opts{output} unless -d $opts{output};
    _getGenomeInfo();
    _makeIntraMatrix($opts{binsize}, $opts{output});
}
elsif ( 'makeInterMatrix' =~ /^$function/i ) {
    die "At least -genome and -output are needed!\n"
        unless $opts{genome} and $opts{output};
    mkdir $opts{output} unless -d $opts{output};
    _getGenomeInfo();
    _makeInterMatrix($opts{binsize}, $opts{output});
}
elsif ( 'calcIntraMatrixPCC' =~ /^$function/i  ) {
    die "-genome, -d1, -d2 and -output are needed!\n"
        unless $opts{d1} and $opts{d2} and $opts{genome}
            and $opts{output};
    _getGenomeInfo();
    my $cutoff = $opts{cutoff} || 2;
    _calcIntraMatrixPCC($opts{d1}, $opts{d2}, $opts{output}, $cutoff);
}
elsif ( 'compartment' =~ /^$function/i ) {
    die "-genome is needed!\n" unless $opts{genome};
    require Statistics::R;
    _getGenomeInfo();
    for my $chr (@chrs) {
        _compartment($chr);
    }
}
elsif ( 'pcatobedgraph' =~ /^$function/i ) {
    die "At least one of -genome and -chr is needed!\n"
        unless $opts{genome} or $opts{chr};
    die "-output is needed!\n" unless $opts{output};
    $opts{pc} = 1 unless $opts{pc};
    unlink $opts{output} if -e $opts{output};
    if ($opts{genome}) {
        _getGenomeInfo();
        for my $chr (@chrs) {
            _pcatobedgraph($chr, $opts{pc}, $opts{output});
        }
    }
    else {
        _pcatobedgraph(@opts{qw(chr pc output)});
    }
}
elsif ( 'diffCompartments' =~ /^$function/i  ) {
    die "-sample1, -sample2 and -output are needed!\n"
        unless $opts{sample1} and $opts{sample2} and $opts{output};
    my $foldchange = $opts{foldchange} || 2;
    my $factor = $opts{factor} || 3;
    my $windowsize = $opts{windowsize} || 20;
    my $gapsize = $opts{gapsize} || 5;
    _diffCompartments($foldchange, $factor, $windowsize, $gapsize, $opts{output});
}
elsif ( 'callInteractions' =~ /^$function/i  ) {
    die "-genome and -output are needed!\n"
        unless $opts{genome} and $opts{output};
    _getGenomeInfo();
    my $distance = $opts{distance} || 10000;
    my $regionsize = $opts{regionsize} || 1000;
    my $minpts = $opts{minpts} || 3;
    my $pm = Parallel::ForkManager->new( $cpu );
    for my $chr (@chrs) {
        $pm->start() and next;
        _cluster( "$chr.realintra", $regionsize, $minpts,
            "$chr.realclu_intra", $chr, \%chrs, $distance );
        $pm->finish();
    }
    $pm->wait_all_children;
    my $cmd = join(' ', 'cat', map {"$_.realclu_intra"} @chrs) . " > $opts{output}.txt";
    system($cmd) == 0 or die "CMD: $cmd failed\n";
    unlink "$_.realclu_intra" for @chrs;
    _intraToBed("$opts{output}.txt", "$opts{output}");
    unlink "$opts{output}.txt";
}
elsif ( 'annotateInteractions' =~ /^$function/i  ) {
    die "At least one of -intra and -inter is needed!\n"
      unless $opts{intra}
      or $opts{inter};
    die "Gene annotation file is needed for annotating interactions!\n"
      unless $opts{gene};
    die "Please specify output file name!\n" unless $opts{output};
    $opts{upstream} = 5_000 unless $opts{upstream};
    $opts{downstream} = 5_000 unless $opts{downstream};
    $opts{ratio} = 0.5 unless $opts{ratio};
    $opts{length} = 1_000 unless $opts{length};
    _annotateInteractions();
}
elsif ( 'parseAnnotate' =~ /^$function/i  ) {
    die "-input and -output are needed!\n"
        unless $opts{input} and $opts{output};
    _parseAnnotate(@opts{qw(input output)});
}
elsif ( 'getInteractedGenes' =~ /^$function/i  ) {
    die "-input and -output are needed!\n"
        unless $opts{input} and $opts{output};
    $opts{single} = 0 unless $opts{single};
    _getInteractedGenes(@opts{qw(input output single)});
}
elsif ( 'selectInteractions' =~ /^$function/i ) {
    die "Gene list file is needed for selecting interactions!\n"
      unless $opts{gene};
    die "Interaction annotation file is needed for selecting interactions!\n"
        unless $opts{annotation};
    die "Please specify output file name!\n" unless $opts{output};
    $opts{type} = 'intra' unless $opts{type};
    die "-type must be one of 'intra',  'inter' and 'all' for 'select'!\n"
      unless $opts{type} eq 'intra'
        or $opts{type} eq 'inter' or $opts{type} eq 'all';
    _selectInteractions(@opts{qw(gene annotation type merge output)});
}
elsif ( 'interactionsToWashU' =~ /^$function/i  ) {
    die "-intra and -output are needed!\n"
        unless $opts{intra} and $opts{output};
    _interactionsToWashU(@opts{qw(intra output)});
}
elsif ( 'intraTxtToBed' =~ /^$function/i  ) {
    die "-intra and -output are needed!\n"
        unless $opts{intra} and $opts{output};
    _intraToBed(@opts{qw(intra output)});
}
elsif ( 'callDIdomains' =~ /^$function/i  ) {
    die "-input , -genome and -output are needed!\n"
        unless $opts{input} and $opts{genome} and $opts{output};
    _getGenomeInfo();
    $cpu = 10 if $cpu > 10;
    _callDIdomains(@opts{qw(input genome output)});
}
elsif ( 'insulationMatrix' =~ /^$function/i  ) {
    die "-genome and -output are needed!\n"
        unless $opts{genome} and $opts{output};
    _getGenomeInfo();
    _insulationMatrix(@opts{qw(genome output)});
}
elsif ( 'checkABcompartments' =~ /^$function/i  ) {
    die "-genome and -input are needed!\n"
        unless $opts{genome} and $opts{input};
    _checkABcompartments(@opts{qw(input genome)});
}
elsif ( 'calcInsulationScores' =~ /^$function/i  ) {
    die "-genome and -output are needed!\n"
        unless $opts{genome} and $opts{output};
    _getGenomeInfo();
    $opts{windowsize} = 20 unless $opts{windowsize};
    _calcInsulationScores(@opts{qw(output windowsize)})
}
elsif ( 'callInsulationTADs' =~ /^$function/i  ) {
    die "-input, -genome and -output are needed!\n"
        unless $opts{input} and $opts{genome} and $opts{output};
    _getGenomeInfo();
    $opts{cutoff} = 0.9 unless defined $opts{cutoff};
    $opts{windowsize} = 3 unless defined $opts{windowsize};
    $opts{boundarySize} = 5 unless defined $opts{boundarySize};
    _callInsulationTADs(@opts{qw(input windowsize boundarySize output)});
    _bgzipFile($opts{output});
}
elsif ( '' =~ /^$function/i  ) {
}
else {
    die "Unknown function '$function' called!\n";
}



#############################################################################
#############################################################################
#####                   Functions defined here
#############################################################################
#############################################################################
sub _getGenomeInfo {
    # search and parse chromSizes file to get chromosomes
    die "-genome is NEEDED!\n" unless $opts{genome};
    $genome = $opts{genome};
    if ( -e "$ENV{BOWTIE_INDEXES}/$genome.chromSizes" ) {
        $chromSizesFile = "$ENV{BOWTIE_INDEXES}/$genome.chromSizes";
    }
    elsif ( -e "$ENV{$genome}/$genome.chromSizes" ) {
        $chromSizesFile = "$ENV{$genome}/$genome.chromSizes";
    }
    else {
        system("fetchChromSizes $genome > $genome.chromSizes") == 0
          or die "Failed to fetchChromSizes for '$genome'.\n";
        $chromSizesFile = "$genome.chromSizes";
    }
    my $in_file_name = $chromSizesFile;    # input file name
    open my $in, '<', $in_file_name
      or die "$0 : failed to open  input file '$in_file_name' : $!\n";
    %chrs = map { (split)[0, 1] } <$in>;
    for (keys %chrs) {
        delete $chrs{$_} if /chr.*_/ or /chrM/i or /chrY/i;
    }
    close $in
      or warn "$0 : failed to close input file '$in_file_name' : $!\n";
    unlink $chromSizesFile if $chromSizesFile eq "$genome.chromSizes";
    @chrs = sort { $a cmp $b } keys %chrs;
}

sub _logging {
    my $time = strftime "%Y-%m-%d %H:%M:%S", localtime;
    print join( "\t", "[$time]", @_ ), "\n";
}

sub _searchFqFiles {
    my $dir = shift;
    opendir( my $dh, $dir ) || die "Can't browser the directory: $dir. $!\n";
    my @files = grep { /\.f(ast)?q(\.gz)?$/i } readdir($dh);
    closedir $dh;
    unless (@files) {
        die "No fastq file found under $dir. Please check it.\n";
    }
    my %file;
    for (@files) {
        if (/(.*)[-_](1|2)\.f(ast)?q(\.gz)?$/i) {
            $file{$1}{"R$2"} = $_;
        }
        elsif (/.*[_.](R1|R2).*\.f(ast)?q(\.gz)?$/i) {
            my $type = $1;
            $type = $type =~ /1$/ ? 'R1' : 'R2';
            ( my $name = $_ ) =~ s/.$type//;
            $name =~ s/\.f(ast)?q(\.gz)?$//i;
            $file{$name}{$type} = $_;
        }
        else {
            warn "File '$_' doesn't look like one of a "
              . "paired-end fastq file, ignore it.\n";
        }
    }
    while ( my ( $name, $ref ) = each %file ) {
        unless ( $ref->{R1} and $ref->{R2} ) {
            warn "No paired file found for file ["
              . join( "", values %$ref ) . "], ignore it!\n";
            delete $file{$name};
        }
    }
    unless (%file) {
        die "No paired-end format fastq file found under $dir. "
          . "Please note paired-end files should have -1|-2 or "
          . " _1|_2 before .fastq or .fq or have R1|R2 in name.\n";
    }
    return \%file;
}

sub _getReadsLength {
    my $filename = shift;
    my $seq;
    my $in_file_name = "$filename";    # input file name
    my $in;
    if ( $filename =~ /\.gz$/ ) {
        open $in, "gzip -cd $in_file_name |"
          or die "$0 : failed to open  input file '$in_file_name' : $!\n";
    }
    else {
        open $in, '<', $in_file_name
          or die "$0 : failed to open  input file '$in_file_name' : $!\n";
    }
    while (<$in>) {
        chomp( $seq = <$in> );
        last;
    }
    close $in;
    return length($seq);
}

sub _iterativeMapping {
    my ($fqDir, $readsLength, $ref) = @_;
    my $trim5 = $opts{trim5};
    my $trim3 = $opts{trim3};
    my $mis = $opts{mismatch};
    my $lenstep = $opts{lenstep};
    my $taglen = $opts{taglen};
    my %fqPEfiles = %$ref;
    my @prefix = keys %fqPEfiles;
    my $readsNum;
    my $cpu = $opts{cpu};
    my $halflen = int($lenstep / 2);
    for my $type (qw(R1 R2)) {
        my ($readsStart, $readsEnd) = (0, $readsLength - $taglen);
        # initial mapping, trimming 3' ends
        my $bowtieLog = "$type.bowtie.log";
        unlink $bowtieLog if -e $bowtieLog;
        $readsEnd = 0 if $readsEnd < 0;
        my $cmd = "bowtie -n $mis -m 1 --un un.fq -p $cpu "
          . "-3 $readsEnd --suppress 5,6,7,8 $genome - "
          . "2>>$bowtieLog >$type.hits.txt";
        _printCMD($bowtieLog, $cmd);
        open my $to, "| $cmd"
          or die "Can't open pipeline to shell command $cmd. $!\n";
        my ($in, $seq, $plus, $qlt);
        $readsNum = 0;
        for my $prefix (@prefix) {
            my $file = $fqPEfiles{$prefix}{$type};
            if ( $file =~ /\.gz$/ ) {
                open $in, "gzip -cd $fqDir/$file |" # open a pipe
                  or die "$0 : failed to open  input file '$fqDir/$file' : $!\n";
            }
            else {
                open $in, '<', "$fqDir/$file"
                  or die "$0 : failed to open  input file '$fqDir/$file' : $!\n";
            }
            if ($trim5 and $trim3) {
                while (<$in>) {
                    chomp( $seq = <$in> );
                    $plus = <$in>;
                    chomp( $qlt = <$in> );
                    substr($seq, 0, $trim5, '');
                    substr($qlt, 0, $trim5, '');
                    substr($seq, -$trim3, $trim3, '');
                    substr($qlt, -$trim3, $trim3, '');
                    print {$to} join( "\n", "@" . $readsNum++, $seq, '+', $qlt), "\n";
                }
            }
            elsif ($trim5) {
                while (<$in>) {
                    chomp( $seq = <$in> );
                    $plus = <$in>;
                    chomp( $qlt = <$in> );
                    substr($seq, 0, $trim5, '');
                    substr($qlt, 0, $trim5, '');
                    print {$to} join( "\n", "@" . $readsNum++, $seq, '+', $qlt), "\n";
                }
            }
            elsif ($trim3) {
                while (<$in>) {
                    chomp( $seq = <$in> );
                    $plus = <$in>;
                    chomp( $qlt = <$in> );
                    substr($seq, -$trim3, $trim3, '');
                    substr($qlt, -$trim3, $trim3, '');
                    print {$to} join( "\n", "@" . $readsNum++, $seq, '+', $qlt), "\n";
                }
            }
            else {
                while (<$in>) {
                    chomp( $seq = <$in> );
                    $plus = <$in>;
                    chomp( $qlt = <$in> );
                    print {$to} join( "\n", "@" . $readsNum++, $seq, '+', $qlt), "\n";
                }
            }
            close $in;
            close $to;
            # process unmappable and multiple mapped reads, shift to 3' end
            while ($readsEnd > 0 and -e "un.fq") {
                rename "un.fq", "input.fq";
                $readsStart += $lenstep;
                $readsEnd -= $lenstep;
                last if $readsEnd < -$halflen; # avoid to make too short reads
                if ($readsEnd < 0) {
                    $readsStart += $readsEnd; # make sure reads length is taglen
                    $readsEnd = 0;
                }
                $cmd = "bowtie -n $mis -m 1 --un un.fq -p $cpu -5 $readsStart "
                  . "-3 $readsEnd --suppress 5,6,7,8 $genome input.fq "
                  . "2>>$bowtieLog >>$type.hits.txt";
                _printCMD($bowtieLog, $cmd);
                system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
            }
        }
    }
    unlink "un.fq";
    unlink "input.fq";
    return $readsNum;
}

sub _printCMD {
    my ($file, $cmd) = @_;
    my $dateStr = strftime "%Y-%m-%d %H:%M:%S", localtime;
    my	$to_file_name = "$file";		# output file name
    open  my $to, '>>', $to_file_name
        or die  "$0 : failed to open  output file '$to_file_name' : $!\n";
    print {$to} "[$dateStr] $cmd\n";
    close  $to
        or warn "$0 : failed to close output file '$to_file_name' : $!\n";
}

sub _summaryIterativeResult {
    my ($totalReads, %mapped) = @_;
    for my $type (qw(R1 R2)) {
        open my $in, '<', "$type.bowtie.log";
        while (<$in>) {
            if (/^Reported\s+(\d+)/) {
                $mapped{$type} += $1;
            }
        }
    }
    _logging(
        sprintf(
            "Reads mapping done! Totally:\n"
            . "        processed    mapped    ratio\n"
            . "    R1: % 8.2fM % 8.2fM % 7.2f%%\n"
            . "    R2: % 8.2fM % 8.2fM % 7.2f%%\n",
            $totalReads / 1_000_000, $mapped{R1} / 1_000_000,
            $mapped{R1} / $totalReads * 100,
            $totalReads / 1_000_000, $mapped{R2} / 1_000_000,
            $mapped{R2} / $totalReads * 100,
        )
    );
}

sub _splitMapped {
    my $type = shift;
    my ( @t, $index );
    my %files = ();
    my $cutoff = 2_000_000;
    open my $in, '<', "$type.hits.txt"
      or die "Can't open file $type.hits.txt. $!\n";
    while (<$in>) {
        @t = split; # index, strand, chr, site
        next unless exists $chrs{$t[2]}; # remove excluded chrs
        $index = int( $t[0] / $cutoff );
        print {
            $files{$index}
              or _openPart( "$type.part.$index", $index, \%files )
        } "$t[0]\t$t[2]\t$t[3]\t$t[1]\n"; # index, chr, site, strand
    }
    close $in;
    close $_ for values %files;
    return keys %files;
}

sub _openPart {
    my ( $file, $int, $fref ) = @_;
    open $fref->{$int}, '>', "$file"
      or die "Can't create $file. $!\n";
    return $fref->{$int};
}

sub _pairing {
    my ( $index ) = @_;
    my $totalPaired = 0;    # total paired PETs
    open my $to, '>', "paired.part.$index"
      or die "Can't create file paired.part.$index. $!\n";
    unless (-e "R1.part.$index" and -e "R2.part.$index") {
        unlink "R1.part.$index" if -e "R1.part.$index";
        unlink "R2.part.$index" if -e "R2.part.$index";
        close $to;
        return 0;
    }
    open my $in, '<', "R1.part.$index"
      or die "Can't open file R1.part.$index. $!\n";
    my %sites;
    my ( @t, $chr, $site, $strand );
    while (<$in>) {
        @t = split; # index, chr, site, strand
        $sites{$t[0]} = [@t[1, 2, 3]];
    }
    close $in;
    open $in, '<', "R2.part.$index"
      or die "Can't open file R2.part.$index. $!\n";
    while (<$in>) {
        @t = split; # index, chr, site, strand
        if (exists $sites{$t[0]}) {
            print {$to} join("\t", @{$sites{$t[0]}}, @t[1, 2, 3]), "\n";
            $totalPaired++;
            delete $sites{$t[0]};
        }
    }
    close $in;
    close $to;
    unlink "R1.part.$index";
    unlink "R2.part.$index";
    return $totalPaired;
}

sub _summaryPairingResult {
    my ($totalReads, $pairedPETs) = @_;
    _logging(
        sprintf(
            "Pairing mapped PETs done! Totally:\n"
            . "    processed    paired    ratio\n"
            . "    % 8.2fM % 8.2fM % 8.2f%%\n",
            $totalReads / 1_000_000, $pairedPETs / 1_000_000,
            $pairedPETs / $totalReads * 100
        )
    );
}

sub _splitAndRemoveDup {
    my ( $filename ) = @_;
    my ( %fileHandles, @t );
    open my $in, '<', $filename or die "Can't open file $filename. $!\n";
    while (<$in>) {
        # split all full pets into chrs, keep five columns
        # site1 chr2 site2 strand1 strand2
        @t = split;
        # chr1 site1 strand1 chr2 site2 strand2
        # 0    1     2       3    4     5
        if ( $t[0] eq $t[3] ) {
            if ( $t[1] < $t[4] ) {
                print {
                    $fileHandles{ $t[0] }{"intra"}
                      or _openPets( $t[0], \%fileHandles, 'intra' )
                } join( ' ', @t[ 1, 3, 4, 2, 5 ] ), "\n";
            }
            else {
                print {
                    $fileHandles{ $t[0] }{"intra"}
                      or _openPets( $t[0], \%fileHandles, 'intra' )
                } join( ' ', @t[ 4, 3, 1, 5, 2 ] ), "\n";
            }
        }
        else {
            print {
                $fileHandles{ $t[0] }{"inter"}
                  or _openPets( $t[0], \%fileHandles, 'inter' )
            } join( ' ', @t[ 1, 3, 4, 2, 5 ] ), "\n";
            print {
                $fileHandles{ $t[3] }{"inter"}
                  or _openPets( $t[3], \%fileHandles, 'inter' )
            } join( ' ', @t[ 4, 0, 1, 5, 2 ] ), "\n";
        }
    }
    my $total = $.;    # total pets before remove redundant
    close $in;
    mkdir "tmp.$$" unless -d "tmp.$$";
    my $pm     = Parallel::ForkManager->new( $cpu, "tmp.$$" );
    my %parts;    # how many sub parts for each chr
    $pm->run_on_finish(
        sub {
            my ( $pid, $exit_code, $indent, $exit_sig, $core, $data ) = @_;
            die "Failed to sort pets file '$indent.pets.txt'.\n"
              unless $exit_code == 0;
            $parts{$indent} = $$data;
        }
    );
    for my $chr (@chrs) {    # sort each chr
        for my $type (qw(intra inter)) {
            unless ( $fileHandles{$chr}{$type} ) {    # create an empty file
                open $fileHandles{$chr}{$type}, '>', "$chr.$type.pets.txt";
            }
            close $fileHandles{$chr}{$type};
            $pm->start("$chr$type") and next;
            my $parts = 0;
            open my $in, '<', "$chr.$type.pets.txt"
              or die "Can't open temporary file $chr.$type.pets.txt! $!\n";
            my @parts;
            while (<$in>) {
                @t = split;
                push @parts, [@t];
                if ( $. % $cutoff == 0 ) {    # sort and output this part
                    @parts = sort {
                        $a->[0] <=> $b->[0]         # site1
                          or $a->[2] <=> $b->[2]    # site2
                          or $a->[1] cmp $b->[1]    # chr2
                          or $a->[3] cmp $b->[3]    # strand1
                    } @parts;
                    $parts++;
                    open my $to, '>', "$chr.$type.pets.txt.sorted.$parts"
                      or die
                      "Can't create $chr.$type.pets.txt.sorted.$parts. $!\n";
                    print {$to} join( " ", @$_ ) . "\n" for @parts;
                    close $to;
                    @parts = ();
                }
            }
            close $in;
            unlink "$chr.$type.pets.txt";
            if (@parts) {
                @parts = sort {
                    $a->[0] <=> $b->[0]         # site1
                      or $a->[2] <=> $b->[2]    # site2
                      or $a->[1] cmp $b->[1]    # chr2
                      or $a->[3] cmp $b->[3]    # strand1
                } @parts;
                $parts++;
                open my $to, '>', "$chr.$type.pets.txt.sorted.$parts"
                  or die
                  "Can't create file $chr.$type.pets.txt.sorted.$parts. $!\n";
                print {$to} join( " ", @$_ ) . "\n" for @parts;
                close $to;
            }
            unless ($parts) { # input file is empty, create an empty sorted file
                $parts++;
                open my $to, '>', "$chr.$type.pets.txt.sorted.$parts"
                  or die
                  "Can't create file $chr.$type.pets.txt.sorted.$parts. $!\n";
                close $to;
            }
            $pm->finish( 0, \$parts );
        }
    }
    $pm->wait_all_children();
    $pm->run_on_finish(
        sub {
            my ( $pid, $exit_code, $indent ) = @_;
            die "Failed to merge pets file '$indent.pets.txt'.\n"
              unless $exit_code == 0;
        }
    );
    for my $chr (@chrs) {    # merge each chr one by one
        for my $type (qw(intra inter)) {
            if ( $parts{"$chr$type"} == 1 ) {
                rename(
                    "$chr.$type.pets.txt.sorted.1",
                    "$chr.$type.pets.txt.merged"
                );
            }
            else {
                $pm->start("$chr.$type") and next;
                my $max = int( ( $parts{"$chr$type"} - 1 ) / 10 ); # 1-10, 11-20
                for my $id ( 0 .. $max ) {
                    my @files = ("$chr.$type.pets.txt.merged.$id");
                    for ( 1 .. 10 ) {
                        my $part = $_ + $id * 10;
                        $part <= $parts{"$chr$type"}
                          ? push @files, "$chr.$type.pets.txt.sorted.$part"
                          : last;
                    }
                    _merge(@files);
                    shift @files;
                    unlink @files;
                }
                if ( $max == 0 ) {
                    rename(
                        "$chr.$type.pets.txt.merged.0",
                        "$chr.$type.pets.txt.merged"
                    );
                }
                else {    # merge merged files
                    my @files = ("$chr.$type.pets.txt.merged");
                    for ( 0 .. $max ) {
                        push @files, "$chr.$type.pets.txt.merged.$_";
                    }
                    _merge(@files);
                    shift @files;
                    unlink @files;
                }
                $pm->finish();
            }
        }
    }
    $pm->wait_all_children();
    my ( $intraKept, $interKept ) = ( 0, 0 );
    $pm->run_on_finish(
        sub {
            my ( $pid, $exit_code, $indent, $exit_sig, $core, $data ) = @_;
            die "Remove redundant pets for '$indent.pets.txt.merged' failed.\n"
              unless $exit_code == 0;
            if ( $indent =~ /intra$/ ) {
                $intraKept += $$data;
            }
            else {
                $interKept += $$data;
            }
        }
    );
    for my $chr (@chrs) {    # remove duplicated pets for each chr
        $pm->start("$chr.intra") and next;
        my $kept =
          _removeDup( "$chr.realintra", "$chr.intra.pets.txt.merged" );
        unlink "$chr.intra.pets.txt.merged";
        $pm->finish( 0, \$kept );
    }
    for my $chr (@chrs) {    # remove duplicated pets for each chr
        $pm->start("$chr.inter") and next;
        my $kept =
          _removeDup( "$chr.realinter", "$chr.inter.pets.txt.merged" );
        unlink "$chr.inter.pets.txt.merged";
        $pm->finish( 0, \$kept );
    }
    $pm->wait_all_children();
    $interKept /= 2;         # inter-pets are print twice to each chr
    my $result =
        "Removing redundant pets done.\n"
      . "    #Total    #Intra.kept    #Inter.kept    %ratio\n"
      . sprintf("%9.2fM%14.2fM%14.2fM%9.2f%%\n",
          $total / 1_000_000,
          $intraKept / 1_000_000,
          $interKept / 1_000_000,
          ( $intraKept + $interKept ) / $total * 100
      );
    _logging($result);
    rmdir "tmp.$$" or warn "Can't delete temporary folder tmp.$$. $!\n";
}

sub _openPets {
    my ( $chr, $fhRef, $type ) = @_;
    open $fhRef->{$chr}{$type}, '>', "$chr.$type.pets.txt"
      or die "Can't create file $chr.$type.pets.txt! $!\n";
    return $fhRef->{$chr}{$type};
}

sub _merge {
    my ( $foutput, @files ) = @_;
    open my $to, '>', $foutput or die "Can't create file $foutput. $!\n";
    my $total = 1_000_000;    # maximun lines number to sort
    my %fhandles;             # input file handles
    my %nonEmpty;
    for my $id ( 0 .. $#files ) {
        open $fhandles{$id}, '<', $files[$id]
          or die "Can't open file $files[$id]. $!\n";
        $nonEmpty{$id} = 0;    # the last read line for each file
    }
    my ( @lines, @t, @l, $lastSite, $count, $smallChr, $smallSite );

    # read in part of each file
    my $cutoff = int( $total / scalar( keys %nonEmpty ) );
    for my $id ( keys %nonEmpty ) {
        $count = 0;
        while ( readline $fhandles{$id} ) {
            @t = split;
            push @lines, [@t];
            last if ++$count == $cutoff;
        }
        if   ( eof $fhandles{$id} ) { delete $nonEmpty{$id}; }
        else                        { $nonEmpty{$id} = $t[0]; }
    }
    while (@lines) {
        @lines = sort {
            $a->[0] <=> $b->[0]         # site1
              or $a->[1] cmp $b->[1]    # chr2
              or $a->[2] <=> $b->[2]    # site2
              or $a->[3] cmp $b->[3]    # strand1
        } @lines;
        if (%nonEmpty) {
            $smallChr =
              ( sort { $nonEmpty{$a} <=> $nonEmpty{$b} } keys %nonEmpty )[0];
            $smallSite = $nonEmpty{$smallChr};
            while (@lines) {
                @l = @{ +shift @lines };
                if ( $l[0] < $smallSite ) {
                    print {$to} join( " ", @l ), "\n";
                }
                else {
                    unshift @lines, [@l];
                    last;
                }
            }
            $cutoff = $total - @lines;
            $count = 0;
            while ( readline $fhandles{$smallChr} ) {
                @t = split;
                push @lines, [@t];
                last if ++$count == $cutoff;
            }
            if ( eof $fhandles{$smallChr} ) {
                delete $nonEmpty{$smallChr};
            }
            else { $nonEmpty{$smallChr} = $t[0]; }
        }
        else {
            print {$to} join( " ", @$_ ) . "\n" for @lines;
            last;
        }
    }
    for my $id ( 0 .. $#files ) {
        close $fhandles{$id};
    }
    close $to;
}

sub _removeDup {
    my ( $foutput, $finput ) = @_;
    open my $in, '<', $finput  or die "Can't open file $finput. $!\n";
    open my $to, '>', $foutput or die "Can't append to file $foutput. $!\n";
    my (@lines, @t, @s);
    my $kept = 0;
    my $s = -1;
    while (<$in>) {
        push @lines, $_;
        if ( $. % $cutoff == 0 ) {
            for (@lines) {
                @t = split;
                next if $t[2] == $s;
                $s = $t[2];
                $kept++;
                print {$to} $_;
            }
            @lines = ();
        }
    }
    for (@lines) {
        @t = split;
        next if $t[2] == $s;
        $s = $t[2];
        $kept++;
        print {$to} $_;
    }
    close $in;
    close $to;
    return $kept;
}

sub _removeSelfLigation {
    my ( $dir ) = @_;
    my $self  = $opts{selflen};
    mkdir "tmp.$$" unless -d "tmp.$$";
    my $pm = Parallel::ForkManager->new( $cpu, "tmp.$$" );
    my ($total, $kept) = (0, 0);
    $pm->run_on_finish(
        sub {
            my ( $pid, $exit_code, $indent, $exit_sig, $core, $data ) = @_;
            die "Remove self-ligated pets for '$indent.realintra' failed.\n"
              unless $exit_code == 0;
            $total += $data->[0];
            $kept  += $data->[1];
        }
    );
    for my $chr (@chrs) {
        $pm->start($chr) and next;
        system("cp $chr.realinter $dir/$chr.realinter") == 0
            or die "CMD: cp $chr.realinter $dir/$chr.realinter failed. $!\n";
        $pm->finish( 0, [0, 0] );
    }
    for my $chr (@chrs) {
        $pm->start($chr) and next;
        my ($total, $kept) = (0, 0);
        open my $in, '<', "$chr.realintra" or die "Can't open file $chr.realintra. $!\n";
        open my $to, '>', "$dir/$chr.realintra"
          or die "Can't create file $dir/$chr.realintra. $!\n";
        while (<$in>) {
            my @t = split;
            next if $t[2] - $t[0] < $self;
            $kept++;
            print {$to} $_;
        }
        $total = $.;
        close $in;
        close $to;
        #unlink "$chr.realintra";
        $pm->finish( 0, [$total, $kept] );
    }
    $pm->wait_all_children();
    rmdir "tmp.$$" or warn "Can't delete temporary folder tmp.$$. $!\n";
    my $log = "Remove self-ligated intra-pets done! Totally:\n";
    $log .= "    #Total    #Kept    %Ratio\n";
    $log .= sprintf("%9.2fM%9.2fM%9.2f%%\n",
        $total / 1_000_000,
        $kept  / 1_000_000,
        $kept  / $total * 100
    );
    _logging($log);
}

sub _checkEnzyme {
    my %allEnzymes;
    #_addEnzyme(\%allEnzymes, enzymeName, enzymeSeq, 5'overhang);
    _addEnzyme(\%allEnzymes,      'AanI',   'TTATAA', 3);
    _addEnzyme(\%allEnzymes,     'AatII',   'GACGTC', 5);
    _addEnzyme(\%allEnzymes,      'AbsI', 'CCTCGAGG', 2);
    _addEnzyme(\%allEnzymes,    'Acc16I',   'TGCGCA', 3);
    _addEnzyme(\%allEnzymes,    'Acc65I',   'GGTACC', 1);
    _addEnzyme(\%allEnzymes,    'AccBSI',   'CCGCTC', 3);
    _addEnzyme(\%allEnzymes,     'AccII',     'CGCG', 2);
    _addEnzyme(\%allEnzymes,    'AccIII',   'TCCGGA', 1);
    _addEnzyme(\%allEnzymes,      'AciI',     'CCGC', 1);
    _addEnzyme(\%allEnzymes,      'AclI',   'AACGTT', 2);
    _addEnzyme(\%allEnzymes,      'AcvI',   'CACGTG', 3);
    _addEnzyme(\%allEnzymes,      'AfaI',     'GTAC', 2);
    _addEnzyme(\%allEnzymes,      'AfeI',   'AGCGCT', 3);
    _addEnzyme(\%allEnzymes,     'AflII',   'CTTAAG', 1);
    _addEnzyme(\%allEnzymes,      'AgeI',   'ACCGGT', 1);
    _addEnzyme(\%allEnzymes,    'AhaIII',   'TTTAAA', 3);
    _addEnzyme(\%allEnzymes,      'AhlI',   'ACTAGT', 1);
    _addEnzyme(\%allEnzymes,      'AjiI',   'CACGTC', 3);
    _addEnzyme(\%allEnzymes,     'AluBI',     'AGCT', 2);
    _addEnzyme(\%allEnzymes,      'AluI',     'AGCT', 2);
    _addEnzyme(\%allEnzymes,    'Alw44I',   'GTGCAC', 1);
    _addEnzyme(\%allEnzymes,   'Aor13HI',   'TCCGGA', 1);
    _addEnzyme(\%allEnzymes,   'Aor51HI',   'AGCGCT', 3);
    _addEnzyme(\%allEnzymes,      'AoxI',     'GGCC', 0);
    _addEnzyme(\%allEnzymes,      'ApaI',   'GGGCCC', 5);
    _addEnzyme(\%allEnzymes,     'ApaLI',   'GTGCAC', 1);
    _addEnzyme(\%allEnzymes,      'AscI', 'GGCGCGCC', 2);
    _addEnzyme(\%allEnzymes,      'AseI',   'ATTAAT', 2);
    _addEnzyme(\%allEnzymes,   'Asi256I',     'GATC', 1);
    _addEnzyme(\%allEnzymes,     'AsiGI',   'ACCGGT', 1);
    _addEnzyme(\%allEnzymes,     'AsiSI', 'GCGATCGC', 5);
    _addEnzyme(\%allEnzymes,   'Asp718I',   'GGTACC', 1);
    _addEnzyme(\%allEnzymes,    'AspA2I',   'CCTAGG', 1);
    _addEnzyme(\%allEnzymes,    'AspLEI',     'GCGC', 3);
    _addEnzyme(\%allEnzymes,     'AsuII',   'TTCGAA', 2);
    _addEnzyme(\%allEnzymes,    'AsuNHI',   'GCTAGC', 1);
    _addEnzyme(\%allEnzymes,     'AvrII',   'CCTAGG', 1);
    _addEnzyme(\%allEnzymes,      'BalI',   'TGGCCA', 3);
    _addEnzyme(\%allEnzymes,     'BamHI',   'GGATCC', 1);
    _addEnzyme(\%allEnzymes,      'BauI',   'CACGAG', 1);
    _addEnzyme(\%allEnzymes,     'BbrPI',   'CACGTG', 3);
    _addEnzyme(\%allEnzymes,     'BbvCI',  'CCTCAGC', 2);
    _addEnzyme(\%allEnzymes,      'BclI',   'TGATCA', 1);
    _addEnzyme(\%allEnzymes,      'BcuI',   'ACTAGT', 1);
    _addEnzyme(\%allEnzymes,      'BfaI',     'CTAG', 1);
    _addEnzyme(\%allEnzymes,      'BfrI',   'CTTAAG', 1);
    _addEnzyme(\%allEnzymes,     'BfuCI',     'GATC', 0);
    _addEnzyme(\%allEnzymes,     'BglII',   'AGATCT', 1);
    _addEnzyme(\%allEnzymes,      'BlnI',   'CCTAGG', 1);
    _addEnzyme(\%allEnzymes,     'BmcAI',   'AGTACT', 3);
    _addEnzyme(\%allEnzymes,     'BmgBI',   'CACGTC', 3);
    _addEnzyme(\%allEnzymes,      'BmtI',   'GCTAGC', 5);
    _addEnzyme(\%allEnzymes,    'Bpu14I',   'TTCGAA', 2);
    _addEnzyme(\%allEnzymes,    'Bsa29I',   'ATCGAT', 2);
    _addEnzyme(\%allEnzymes,     'BseAI',   'TCCGGA', 1);
    _addEnzyme(\%allEnzymes,     'BseCI',   'ATCGAT', 2);
    _addEnzyme(\%allEnzymes,     'BsePI',   'GCGCGC', 1);
    _addEnzyme(\%allEnzymes,    'BseX3I',   'CGGCCG', 1);
    _addEnzyme(\%allEnzymes,     'BseYI',   'CCCAGC', 1);
    _addEnzyme(\%allEnzymes,  'Bsh1236I',     'CGCG', 2);
    _addEnzyme(\%allEnzymes,     'BshFI',     'GGCC', 2);
    _addEnzyme(\%allEnzymes,     'BshTI',   'ACCGGT', 1);
    _addEnzyme(\%allEnzymes,     'BshVI',   'ATCGAT', 2);
    _addEnzyme(\%allEnzymes,      'BsiI',   'CACGAG', 1);
    _addEnzyme(\%allEnzymes,     'BsiSI',     'CCGG', 1);
    _addEnzyme(\%allEnzymes,     'BsiWI',   'CGTACG', 1);
    _addEnzyme(\%allEnzymes,      'BsnI',     'GGCC', 2);
    _addEnzyme(\%allEnzymes,   'Bsp119I',   'TTCGAA', 2);
    _addEnzyme(\%allEnzymes,   'Bsp120I',   'GGGCCC', 1);
    _addEnzyme(\%allEnzymes,    'Bsp13I',   'TCCGGA', 1);
    _addEnzyme(\%allEnzymes,  'Bsp1407I',   'TGTACA', 1);
    _addEnzyme(\%allEnzymes,   'Bsp143I',     'GATC', 0);
    _addEnzyme(\%allEnzymes,    'Bsp19I',   'CCATGG', 1);
    _addEnzyme(\%allEnzymes,    'Bsp68I',   'TCGCGA', 3);
    _addEnzyme(\%allEnzymes,    'BspACI',     'CCGC', 1);
    _addEnzyme(\%allEnzymes,    'BspANI',     'GGCC', 2);
    _addEnzyme(\%allEnzymes,     'BspDI',   'ATCGAT', 2);
    _addEnzyme(\%allEnzymes,     'BspEI',   'TCCGGA', 1);
    _addEnzyme(\%allEnzymes,    'BspFNI',     'CGCG', 2);
    _addEnzyme(\%allEnzymes,     'BspHI',   'TCATGA', 1);
    _addEnzyme(\%allEnzymes,  'BspLU11I',   'ACATGT', 1);
    _addEnzyme(\%allEnzymes,    'BspMAI',   'CTGCAG', 5);
    _addEnzyme(\%allEnzymes,    'BspMII',   'TCCGGA', 1);
    _addEnzyme(\%allEnzymes,     'BspOI',   'GCTAGC', 5);
    _addEnzyme(\%allEnzymes,  'BspT104I',   'TTCGAA', 2);
    _addEnzyme(\%allEnzymes,     'BspTI',   'CTTAAG', 1);
    _addEnzyme(\%allEnzymes,     'BsrBI',   'CCGCTC', 3);
    _addEnzyme(\%allEnzymes,     'BsrGI',   'TGTACA', 1);
    _addEnzyme(\%allEnzymes,    'BssHII',   'GCGCGC', 1);
    _addEnzyme(\%allEnzymes,     'BssMI',     'GATC', 0);
    _addEnzyme(\%allEnzymes,    'BssNAI',   'GTATAC', 3);
    _addEnzyme(\%allEnzymes,     'BssSI',   'CACGAG', 1);
    _addEnzyme(\%allEnzymes,  'Bst1107I',   'GTATAC', 3);
    _addEnzyme(\%allEnzymes,    'Bst2BI',   'CACGAG', 1);
    _addEnzyme(\%allEnzymes,    'BstAFI',   'CTTAAG', 1);
    _addEnzyme(\%allEnzymes,    'BstAUI',   'TGTACA', 1);
    _addEnzyme(\%allEnzymes,     'BstBI',   'TTCGAA', 2);
    _addEnzyme(\%allEnzymes,    'BstFNI',     'CGCG', 2);
    _addEnzyme(\%allEnzymes,    'BstHHI',     'GCGC', 3);
    _addEnzyme(\%allEnzymes,    'BstKTI',     'GATC', 3);
    _addEnzyme(\%allEnzymes,    'BstMBI',     'GATC', 0);
    _addEnzyme(\%allEnzymes,    'BstSNI',   'TACGTA', 3);
    _addEnzyme(\%allEnzymes,     'BstUI',     'CGCG', 2);
    _addEnzyme(\%allEnzymes,   'BstZ17I',   'GTATAC', 3);
    _addEnzyme(\%allEnzymes,     'BstZI',   'CGGCCG', 1);
    _addEnzyme(\%allEnzymes,    'Bsu15I',   'ATCGAT', 2);
    _addEnzyme(\%allEnzymes,     'BsuRI',     'GGCC', 2);
    _addEnzyme(\%allEnzymes,    'BsuTUI',   'ATCGAT', 2);
    _addEnzyme(\%allEnzymes,      'BtrI',   'CACGTC', 3);
    _addEnzyme(\%allEnzymes,     'BtuMI',   'TCGCGA', 3);
    _addEnzyme(\%allEnzymes,      'CciI',   'TCATGA', 1);
    _addEnzyme(\%allEnzymes,     'CciNI', 'GCGGCCGC', 2);
    _addEnzyme(\%allEnzymes,      'CfoI',     'GCGC', 3);
    _addEnzyme(\%allEnzymes,    'Cfr42I',   'CCGCGG', 4);
    _addEnzyme(\%allEnzymes,     'Cfr9I',   'CCCGGG', 1);
    _addEnzyme(\%allEnzymes,      'ChaI',     'GATC', 4);
    _addEnzyme(\%allEnzymes,      'ClaI',   'ATCGAT', 2);
    _addEnzyme(\%allEnzymes,     'Csp6I',     'GTAC', 1);
    _addEnzyme(\%allEnzymes,     'CspAI',   'ACCGGT', 1);
    _addEnzyme(\%allEnzymes,    'CviAII',     'CATG', 1);
    _addEnzyme(\%allEnzymes,     'CviQI',     'GTAC', 1);
    _addEnzyme(\%allEnzymes,     'CviRI',     'TGCA', 2);
    _addEnzyme(\%allEnzymes,      'DinI',   'GGCGCC', 3);
    _addEnzyme(\%allEnzymes,      'DpnI',     'GATC', 2);
    _addEnzyme(\%allEnzymes,     'DpnII',     'GATC', 0);
    _addEnzyme(\%allEnzymes,      'DraI',   'TTTAAA', 3);
    _addEnzyme(\%allEnzymes,      'EagI',   'CGGCCG', 1);
    _addEnzyme(\%allEnzymes,  'Ecl136II',   'GAGCTC', 3);
    _addEnzyme(\%allEnzymes,     'EclXI',   'CGGCCG', 1);
    _addEnzyme(\%allEnzymes,   'Eco105I',   'TACGTA', 3);
    _addEnzyme(\%allEnzymes,   'Eco147I',   'AGGCCT', 3);
    _addEnzyme(\%allEnzymes,    'Eco32I',   'GATATC', 3);
    _addEnzyme(\%allEnzymes,  'Eco47III',   'AGCGCT', 3);
    _addEnzyme(\%allEnzymes,    'Eco52I',   'CGGCCG', 1);
    _addEnzyme(\%allEnzymes,   'Eco53kI',   'GAGCTC', 3);
    _addEnzyme(\%allEnzymes,    'Eco72I',   'CACGTG', 3);
    _addEnzyme(\%allEnzymes,   'EcoICRI',   'GAGCTC', 3);
    _addEnzyme(\%allEnzymes,     'EcoRI',   'GAATTC', 1);
    _addEnzyme(\%allEnzymes,     'EcoRV',   'GATATC', 3);
    _addEnzyme(\%allEnzymes,   'EcoT22I',   'ATGCAT', 5);
    _addEnzyme(\%allEnzymes,      'EgeI',   'GGCGCC', 3);
    _addEnzyme(\%allEnzymes,      'EheI',   'GGCGCC', 3);
    _addEnzyme(\%allEnzymes,   'EsaBC3I',     'TCGA', 2);
    _addEnzyme(\%allEnzymes,      'FaeI',     'CATG', 4);
    _addEnzyme(\%allEnzymes,      'FatI',     'CATG', 0);
    _addEnzyme(\%allEnzymes,    'FauNDI',   'CATATG', 2);
    _addEnzyme(\%allEnzymes,      'FbaI',   'TGATCA', 1);
    _addEnzyme(\%allEnzymes,    'FnuDII',     'CGCG', 2);
    _addEnzyme(\%allEnzymes,      'FseI', 'GGCCGGCC', 6);
    _addEnzyme(\%allEnzymes,     'FspBI',     'CTAG', 1);
    _addEnzyme(\%allEnzymes,      'FspI',   'TGCGCA', 3);
    _addEnzyme(\%allEnzymes,      'GlaI',     'GCGC', 2);
    _addEnzyme(\%allEnzymes,      'GsaI',   'CCCAGC', 5);
    _addEnzyme(\%allEnzymes,    'HaeIII',     'GGCC', 2);
    _addEnzyme(\%allEnzymes,     'HapII',     'CCGG', 1);
    _addEnzyme(\%allEnzymes,      'HhaI',     'GCGC', 3);
    _addEnzyme(\%allEnzymes,    'Hin1II',     'CATG', 4);
    _addEnzyme(\%allEnzymes,     'Hin6I',     'GCGC', 1);
    _addEnzyme(\%allEnzymes,    'HinP1I',     'GCGC', 1);
    _addEnzyme(\%allEnzymes,   'HindIII',   'AAGCTT', 1);
    _addEnzyme(\%allEnzymes,      'HpaI',   'GTTAAC', 3);
    _addEnzyme(\%allEnzymes,     'HpaII',     'CCGG', 1);
    _addEnzyme(\%allEnzymes,  'HpyCH4IV',     'ACGT', 1);
    _addEnzyme(\%allEnzymes,   'HpyCH4V',     'TGCA', 2);
    _addEnzyme(\%allEnzymes, 'HpySE526I',     'ACGT', 1);
    _addEnzyme(\%allEnzymes,   'Hsp92II',     'CATG', 4);
    _addEnzyme(\%allEnzymes,     'HspAI',     'GCGC', 1);
    _addEnzyme(\%allEnzymes,      'KasI',   'GGCGCC', 1);
    _addEnzyme(\%allEnzymes,     'Kpn2I',   'TCCGGA', 1);
    _addEnzyme(\%allEnzymes,      'KpnI',   'GGTACC', 5);
    _addEnzyme(\%allEnzymes,      'KroI',   'GCCGGC', 1);
    _addEnzyme(\%allEnzymes,    'Ksp22I',   'TGATCA', 1);
    _addEnzyme(\%allEnzymes,     'KspAI',   'GTTAAC', 3);
    _addEnzyme(\%allEnzymes,      'KspI',   'CCGCGG', 4);
    _addEnzyme(\%allEnzymes,     'Kzo9I',     'GATC', 0);
    _addEnzyme(\%allEnzymes,      'MaeI',     'CTAG', 1);
    _addEnzyme(\%allEnzymes,     'MaeII',     'ACGT', 1);
    _addEnzyme(\%allEnzymes,      'MalI',     'GATC', 2);
    _addEnzyme(\%allEnzymes,     'MauBI', 'CGCGCGCG', 2);
    _addEnzyme(\%allEnzymes,      'MbiI',   'CCGCTC', 3);
    _addEnzyme(\%allEnzymes,      'MboI',     'GATC', 0);
    _addEnzyme(\%allEnzymes,     'McaTI',   'GCGCGC', 4);
    _addEnzyme(\%allEnzymes,      'MfeI',   'CAATTG', 1);
    _addEnzyme(\%allEnzymes,      'MlsI',   'TGGCCA', 3);
    _addEnzyme(\%allEnzymes,     'MluCI',     'AATT', 0);
    _addEnzyme(\%allEnzymes,      'MluI',   'ACGCGT', 1);
    _addEnzyme(\%allEnzymes,     'MluNI',   'TGGCCA', 3);
    _addEnzyme(\%allEnzymes,   'Mly113I',   'GGCGCC', 2);
    _addEnzyme(\%allEnzymes,    'Mox20I',   'TGGCCA', 3);
    _addEnzyme(\%allEnzymes,  'Mph1103I',   'ATGCAT', 5);
    _addEnzyme(\%allEnzymes,      'MreI', 'CGCCGGCG', 2);
    _addEnzyme(\%allEnzymes,      'MroI',   'TCCGGA', 1);
    _addEnzyme(\%allEnzymes,     'MroNI',   'GCCGGC', 1);
    _addEnzyme(\%allEnzymes,      'MscI',   'TGGCCA', 3);
    _addEnzyme(\%allEnzymes,      'MseI',     'TTAA', 1);
    _addEnzyme(\%allEnzymes,    'Msp20I',   'TGGCCA', 3);
    _addEnzyme(\%allEnzymes,     'MspCI',   'CTTAAG', 1);
    _addEnzyme(\%allEnzymes,      'MspI',     'CCGG', 1);
    _addEnzyme(\%allEnzymes,      'MssI', 'GTTTAAAC', 4);
    _addEnzyme(\%allEnzymes,      'MstI',   'TGCGCA', 3);
    _addEnzyme(\%allEnzymes,      'MunI',   'CAATTG', 1);
    _addEnzyme(\%allEnzymes,      'MvnI',     'CGCG', 2);
    _addEnzyme(\%allEnzymes,      'NaeI',   'GCCGGC', 3);
    _addEnzyme(\%allEnzymes,      'NarI',   'GGCGCC', 2);
    _addEnzyme(\%allEnzymes,      'NcoI',   'CCATGG', 1);
    _addEnzyme(\%allEnzymes,      'NdeI',   'CATATG', 2);
    _addEnzyme(\%allEnzymes,     'NdeII',     'GATC', 0);
    _addEnzyme(\%allEnzymes,    'NgoMIV',   'GCCGGC', 1);
    _addEnzyme(\%allEnzymes,      'NheI',   'GCTAGC', 1);
    _addEnzyme(\%allEnzymes,    'NlaIII',     'CATG', 4);
    _addEnzyme(\%allEnzymes,      'NotI', 'GCGGCCGC', 2);
    _addEnzyme(\%allEnzymes,      'NruI',   'TCGCGA', 3);
    _addEnzyme(\%allEnzymes,      'NsbI',   'TGCGCA', 3);
    _addEnzyme(\%allEnzymes,      'NsiI',   'ATGCAT', 5);
    _addEnzyme(\%allEnzymes,      'NspV',   'TTCGAA', 2);
    _addEnzyme(\%allEnzymes,      'PabI',     'GTAC', 3);
    _addEnzyme(\%allEnzymes,      'PacI', 'TTAATTAA', 5);
    _addEnzyme(\%allEnzymes,      'PaeI',   'GCATGC', 5);
    _addEnzyme(\%allEnzymes,    'PaeR7I',   'CTCGAG', 1);
    _addEnzyme(\%allEnzymes,      'PagI',   'TCATGA', 1);
    _addEnzyme(\%allEnzymes,     'PalAI', 'GGCGCGCC', 2);
    _addEnzyme(\%allEnzymes,      'PauI',   'GCGCGC', 1);
    _addEnzyme(\%allEnzymes,      'PceI',   'AGGCCT', 3);
    _addEnzyme(\%allEnzymes,      'PciI',   'ACATGT', 1);
    _addEnzyme(\%allEnzymes,      'PdiI',   'GCCGGC', 3);
    _addEnzyme(\%allEnzymes,   'Pfl23II',   'CGTACG', 1);
    _addEnzyme(\%allEnzymes,     'PinAI',   'ACCGGT', 1);
    _addEnzyme(\%allEnzymes,    'Ple19I',   'CGATCG', 4);
    _addEnzyme(\%allEnzymes,     'PluTI',   'GGCGCC', 5);
    _addEnzyme(\%allEnzymes,     'PmaCI',   'CACGTG', 3);
    _addEnzyme(\%allEnzymes,      'PmeI', 'GTTTAAAC', 4);
    _addEnzyme(\%allEnzymes,      'PmlI',   'CACGTG', 3);
    _addEnzyme(\%allEnzymes,    'Ppu10I',   'ATGCAT', 1);
    _addEnzyme(\%allEnzymes,      'PscI',   'ACATGT', 1);
    _addEnzyme(\%allEnzymes,     'PshBI',   'ATTAAT', 2);
    _addEnzyme(\%allEnzymes,      'PsiI',   'TTATAA', 3);
    _addEnzyme(\%allEnzymes,  'Psp124BI',   'GAGCTC', 5);
    _addEnzyme(\%allEnzymes,  'Psp1406I',   'AACGTT', 2);
    _addEnzyme(\%allEnzymes,     'PspCI',   'CACGTG', 3);
    _addEnzyme(\%allEnzymes,     'PspFI',   'CCCAGC', 1);
    _addEnzyme(\%allEnzymes,     'PspLI',   'CGTACG', 1);
    _addEnzyme(\%allEnzymes,    'PspOMI',   'GGGCCC', 1);
    _addEnzyme(\%allEnzymes,      'PstI',   'CTGCAG', 5);
    _addEnzyme(\%allEnzymes,      'PteI',   'GCGCGC', 1);
    _addEnzyme(\%allEnzymes,      'PvuI',   'CGATCG', 4);
    _addEnzyme(\%allEnzymes,     'PvuII',   'CAGCTG', 3);
    _addEnzyme(\%allEnzymes,      'RgaI', 'GCGATCGC', 5);
    _addEnzyme(\%allEnzymes,      'RigI', 'GGCCGGCC', 6);
    _addEnzyme(\%allEnzymes,      'RruI',   'TCGCGA', 3);
    _addEnzyme(\%allEnzymes,      'RsaI',     'GTAC', 2);
    _addEnzyme(\%allEnzymes,     'RsaNI',     'GTAC', 1);
    _addEnzyme(\%allEnzymes,      'SacI',   'GAGCTC', 5);
    _addEnzyme(\%allEnzymes,     'SacII',   'CCGCGG', 4);
    _addEnzyme(\%allEnzymes,      'SalI',   'GTCGAC', 1);
    _addEnzyme(\%allEnzymes,     'SaqAI',     'TTAA', 1);
    _addEnzyme(\%allEnzymes,    'Sau3AI',     'GATC', 0);
    _addEnzyme(\%allEnzymes,      'SbfI', 'CCTGCAGG', 6);
    _addEnzyme(\%allEnzymes,      'ScaI',   'AGTACT', 3);
    _addEnzyme(\%allEnzymes,      'SciI',   'CTCGAG', 3);
    _addEnzyme(\%allEnzymes,      'SdaI', 'CCTGCAGG', 6);
    _addEnzyme(\%allEnzymes,      'SelI',     'CGCG', 0);
    _addEnzyme(\%allEnzymes,     'SfaAI', 'GCGATCGC', 5);
    _addEnzyme(\%allEnzymes,      'SfoI',   'GGCGCC', 3);
    _addEnzyme(\%allEnzymes,   'Sfr274I',   'CTCGAG', 1);
    _addEnzyme(\%allEnzymes,   'Sfr303I',   'CCGCGG', 4);
    _addEnzyme(\%allEnzymes,      'SfuI',   'TTCGAA', 2);
    _addEnzyme(\%allEnzymes,      'SgfI', 'GCGATCGC', 5);
    _addEnzyme(\%allEnzymes,     'SgrBI',   'CCGCGG', 4);
    _addEnzyme(\%allEnzymes,     'SgrDI', 'CGTCGACG', 2);
    _addEnzyme(\%allEnzymes,      'SgsI', 'GGCGCGCC', 2);
    _addEnzyme(\%allEnzymes,      'SlaI',   'CTCGAG', 1);
    _addEnzyme(\%allEnzymes,      'SmaI',   'CCCGGG', 3);
    _addEnzyme(\%allEnzymes,      'SmiI', 'ATTTAAAT', 4);
    _addEnzyme(\%allEnzymes,     'SnaBI',   'TACGTA', 3);
    _addEnzyme(\%allEnzymes,      'SpeI',   'ACTAGT', 1);
    _addEnzyme(\%allEnzymes,      'SphI',   'GCATGC', 5);
    _addEnzyme(\%allEnzymes,      'SplI',   'CGTACG', 1);
    _addEnzyme(\%allEnzymes,      'SrfI', 'GCCCGGGC', 4);
    _addEnzyme(\%allEnzymes,   'Sse232I', 'CGCCGGCG', 2);
    _addEnzyme(\%allEnzymes,  'Sse8387I', 'CCTGCAGG', 6);
    _addEnzyme(\%allEnzymes,     'Sse9I',     'AATT', 0);
    _addEnzyme(\%allEnzymes,     'SseBI',   'AGGCCT', 3);
    _addEnzyme(\%allEnzymes,      'SsiI',     'CCGC', 1);
    _addEnzyme(\%allEnzymes,     'SspDI',   'GGCGCC', 1);
    _addEnzyme(\%allEnzymes,      'SspI',   'AATATT', 3);
    _addEnzyme(\%allEnzymes,     'SspMI',     'CTAG', 1);
    _addEnzyme(\%allEnzymes,      'SstI',   'GAGCTC', 5);
    _addEnzyme(\%allEnzymes,  'Sth302II',     'CCGG', 2);
    _addEnzyme(\%allEnzymes,      'StuI',   'AGGCCT', 3);
    _addEnzyme(\%allEnzymes,      'SwaI', 'ATTTAAAT', 4);
    _addEnzyme(\%allEnzymes,      'TaiI',     'ACGT', 4);
    _addEnzyme(\%allEnzymes,      'TaqI',     'TCGA', 1);
    _addEnzyme(\%allEnzymes,      'TasI',     'AATT', 0);
    _addEnzyme(\%allEnzymes,     'Tru1I',     'TTAA', 1);
    _addEnzyme(\%allEnzymes,     'Tru9I',     'TTAA', 1);
    _addEnzyme(\%allEnzymes,     'TspEI',     'AATT', 0);
    _addEnzyme(\%allEnzymes,     'TspMI',   'CCCGGG', 1);
    _addEnzyme(\%allEnzymes,   'Vha464I',   'CTTAAG', 1);
    _addEnzyme(\%allEnzymes,      'VneI',   'GTGCAC', 1);
    _addEnzyme(\%allEnzymes,      'VspI',   'ATTAAT', 2);
    _addEnzyme(\%allEnzymes,      'XbaI',   'TCTAGA', 1);
    _addEnzyme(\%allEnzymes,      'XhoI',   'CTCGAG', 1);
    _addEnzyme(\%allEnzymes,      'XmaI',   'CCCGGG', 1);
    _addEnzyme(\%allEnzymes,    'XmaIII',   'CGGCCG', 1);
    _addEnzyme(\%allEnzymes,     'XmaJI',   'CCTAGG', 1);
    _addEnzyme(\%allEnzymes,      'XspI',     'CTAG', 1);
    _addEnzyme(\%allEnzymes,      'ZraI',   'GACGTC', 3);
    _addEnzyme(\%allEnzymes,      'ZrmI',   'AGTACT', 3);
    _addEnzyme(\%allEnzymes,     'Zsp2I',   'ATGCAT', 5);

    unless (exists $allEnzymes{uc($opts{enzyme})}) {
        die sprintf("Enzyme $opts{enzyme} is not supported yet, please add it"
            . " after line %d in the file '%s'!\n", __LINE__ - 3, __FILE__);
    }
    $opts{enzymeSeq} = $allEnzymes{uc($opts{enzyme})}{seq};
    $opts{overhang}  = $allEnzymes{uc($opts{enzyme})}{overhang};
}

sub _addEnzyme {
    my ($ref, $name, $seq, $hang) = @_;
    $name = uc($name);
    $ref->{$name}{seq} = $seq;
    $ref->{$name}{overhang} = $hang;
}

sub _supportedEnzymes {
die <<EOF;
	Name      Sequence	5'hanglength
	AanI        TTATAA	3
	AatII       GACGTC	5
	AbsI      CCTCGAGG	2
	Acc16I      TGCGCA	3
	Acc65I      GGTACC	1
	AccBSI      CCGCTC	3
	AccII         CGCG	2
	AccIII      TCCGGA	1
	AciI          CCGC	1
	AclI        AACGTT	2
	AcvI        CACGTG	3
	AfaI          GTAC	2
	AfeI        AGCGCT	3
	AflII       CTTAAG	1
	AgeI        ACCGGT	1
	AhaIII      TTTAAA	3
	AhlI        ACTAGT	1
	AjiI        CACGTC	3
	AluBI         AGCT	2
	AluI          AGCT	2
	Alw44I      GTGCAC	1
	Aor13HI     TCCGGA	1
	Aor51HI     AGCGCT	3
	AoxI          GGCC	0
	ApaI        GGGCCC	5
	ApaLI       GTGCAC	1
	AscI      GGCGCGCC	2
	AseI        ATTAAT	2
	Asi256I       GATC	1
	AsiGI       ACCGGT	1
	AsiSI     GCGATCGC	5
	Asp718I     GGTACC	1
	AspA2I      CCTAGG	1
	AspLEI        GCGC	3
	AsuII       TTCGAA	2
	AsuNHI      GCTAGC	1
	AvrII       CCTAGG	1
	BalI        TGGCCA	3
	BamHI       GGATCC	1
	BauI        CACGAG	1
	BbrPI       CACGTG	3
	BbvCI      CCTCAGC	2
	BclI        TGATCA	1
	BcuI        ACTAGT	1
	BfaI          CTAG	1
	BfrI        CTTAAG	1
	BfuCI         GATC	0
	BglII       AGATCT	1
	BlnI        CCTAGG	1
	BmcAI       AGTACT	3
	BmgBI       CACGTC	3
	BmtI        GCTAGC	5
	Bpu14I      TTCGAA	2
	Bsa29I      ATCGAT	2
	BseAI       TCCGGA	1
	BseCI       ATCGAT	2
	BsePI       GCGCGC	1
	BseX3I      CGGCCG	1
	BseYI       CCCAGC	1
	Bsh1236I      CGCG	2
	BshFI         GGCC	2
	BshTI       ACCGGT	1
	BshVI       ATCGAT	2
	BsiI        CACGAG	1
	BsiSI         CCGG	1
	BsiWI       CGTACG	1
	BsnI          GGCC	2
	Bsp119I     TTCGAA	2
	Bsp120I     GGGCCC	1
	Bsp13I      TCCGGA	1
	Bsp1407I    TGTACA	1
	Bsp143I       GATC	0
	Bsp19I      CCATGG	1
	Bsp68I      TCGCGA	3
	BspACI        CCGC	1
	BspANI        GGCC	2
	BspDI       ATCGAT	2
	BspEI       TCCGGA	1
	BspFNI        CGCG	2
	BspHI       TCATGA	1
	BspLU11I    ACATGT	1
	BspMAI      CTGCAG	5
	BspMII      TCCGGA	1
	BspOI       GCTAGC	5
	BspT104I    TTCGAA	2
	BspTI       CTTAAG	1
	BsrBI       CCGCTC	3
	BsrGI       TGTACA	1
	BssHII      GCGCGC	1
	BssMI         GATC	0
	BssNAI      GTATAC	3
	BssSI       CACGAG	1
	Bst1107I    GTATAC	3
	Bst2BI      CACGAG	1
	BstAFI      CTTAAG	1
	BstAUI      TGTACA	1
	BstBI       TTCGAA	2
	BstFNI        CGCG	2
	BstHHI        GCGC	3
	BstKTI        GATC	3
	BstMBI        GATC	0
	BstSNI      TACGTA	3
	BstUI         CGCG	2
	BstZ17I     GTATAC	3
	BstZI       CGGCCG	1
	Bsu15I      ATCGAT	2
	BsuRI         GGCC	2
	BsuTUI      ATCGAT	2
	BtrI        CACGTC	3
	BtuMI       TCGCGA	3
	CciI        TCATGA	1
	CciNI     GCGGCCGC	2
	CfoI          GCGC	3
	Cfr42I      CCGCGG	4
	Cfr9I       CCCGGG	1
	ChaI          GATC	4
	ClaI        ATCGAT	2
	Csp6I         GTAC	1
	CspAI       ACCGGT	1
	CviAII        CATG	1
	CviQI         GTAC	1
	CviRI         TGCA	2
	DinI        GGCGCC	3
	DpnI          GATC	2
	DpnII         GATC	0
	DraI        TTTAAA	3
	EagI        CGGCCG	1
	Ecl136II    GAGCTC	3
	EclXI       CGGCCG	1
	Eco105I     TACGTA	3
	Eco147I     AGGCCT	3
	Eco32I      GATATC	3
	Eco47III    AGCGCT	3
	Eco52I      CGGCCG	1
	Eco53kI     GAGCTC	3
	Eco72I      CACGTG	3
	EcoICRI     GAGCTC	3
	EcoRI       GAATTC	1
	EcoRV       GATATC	3
	EcoT22I     ATGCAT	5
	EgeI        GGCGCC	3
	EheI        GGCGCC	3
	EsaBC3I       TCGA	2
	FaeI          CATG	4
	FatI          CATG	0
	FauNDI      CATATG	2
	FbaI        TGATCA	1
	FnuDII        CGCG	2
	FseI      GGCCGGCC	6
	FspBI         CTAG	1
	FspI        TGCGCA	3
	GlaI          GCGC	2
	GsaI        CCCAGC	5
	HaeIII        GGCC	2
	HapII         CCGG	1
	HhaI          GCGC	3
	Hin1II        CATG	4
	Hin6I         GCGC	1
	HinP1I        GCGC	1
	HindIII     AAGCTT	1
	HpaI        GTTAAC	3
	HpaII         CCGG	1
	HpyCH4IV      ACGT	1
	HpyCH4V       TGCA	2
	HpySE526I      ACGT	1
	Hsp92II       CATG	4
	HspAI         GCGC	1
	KasI        GGCGCC	1
	Kpn2I       TCCGGA	1
	KpnI        GGTACC	5
	KroI        GCCGGC	1
	Ksp22I      TGATCA	1
	KspAI       GTTAAC	3
	KspI        CCGCGG	4
	Kzo9I         GATC	0
	MaeI          CTAG	1
	MaeII         ACGT	1
	MalI          GATC	2
	MauBI     CGCGCGCG	2
	MbiI        CCGCTC	3
	MboI          GATC	0
	McaTI       GCGCGC	4
	MfeI        CAATTG	1
	MlsI        TGGCCA	3
	MluCI         AATT	0
	MluI        ACGCGT	1
	MluNI       TGGCCA	3
	Mly113I     GGCGCC	2
	Mox20I      TGGCCA	3
	Mph1103I    ATGCAT	5
	MreI      CGCCGGCG	2
	MroI        TCCGGA	1
	MroNI       GCCGGC	1
	MscI        TGGCCA	3
	MseI          TTAA	1
	Msp20I      TGGCCA	3
	MspCI       CTTAAG	1
	MspI          CCGG	1
	MssI      GTTTAAAC	4
	MstI        TGCGCA	3
	MunI        CAATTG	1
	MvnI          CGCG	2
	NaeI        GCCGGC	3
	NarI        GGCGCC	2
	NcoI        CCATGG	1
	NdeI        CATATG	2
	NdeII         GATC	0
	NgoMIV      GCCGGC	1
	NheI        GCTAGC	1
	NlaIII        CATG	4
	NotI      GCGGCCGC	2
	NruI        TCGCGA	3
	NsbI        TGCGCA	3
	NsiI        ATGCAT	5
	NspV        TTCGAA	2
	PabI          GTAC	3
	PacI      TTAATTAA	5
	PaeI        GCATGC	5
	PaeR7I      CTCGAG	1
	PagI        TCATGA	1
	PalAI     GGCGCGCC	2
	PauI        GCGCGC	1
	PceI        AGGCCT	3
	PciI        ACATGT	1
	PdiI        GCCGGC	3
	Pfl23II     CGTACG	1
	PinAI       ACCGGT	1
	Ple19I      CGATCG	4
	PluTI       GGCGCC	5
	PmaCI       CACGTG	3
	PmeI      GTTTAAAC	4
	PmlI        CACGTG	3
	Ppu10I      ATGCAT	1
	PscI        ACATGT	1
	PshBI       ATTAAT	2
	PsiI        TTATAA	3
	Psp124BI    GAGCTC	5
	Psp1406I    AACGTT	2
	PspCI       CACGTG	3
	PspFI       CCCAGC	1
	PspLI       CGTACG	1
	PspOMI      GGGCCC	1
	PstI        CTGCAG	5
	PteI        GCGCGC	1
	PvuI        CGATCG	4
	PvuII       CAGCTG	3
	RgaI      GCGATCGC	5
	RigI      GGCCGGCC	6
	RruI        TCGCGA	3
	RsaI          GTAC	2
	RsaNI         GTAC	1
	SacI        GAGCTC	5
	SacII       CCGCGG	4
	SalI        GTCGAC	1
	SaqAI         TTAA	1
	Sau3AI        GATC	0
	SbfI      CCTGCAGG	6
	ScaI        AGTACT	3
	SciI        CTCGAG	3
	SdaI      CCTGCAGG	6
	SelI          CGCG	0
	SfaAI     GCGATCGC	5
	SfoI        GGCGCC	3
	Sfr274I     CTCGAG	1
	Sfr303I     CCGCGG	4
	SfuI        TTCGAA	2
	SgfI      GCGATCGC	5
	SgrBI       CCGCGG	4
	SgrDI     CGTCGACG	2
	SgsI      GGCGCGCC	2
	SlaI        CTCGAG	1
	SmaI        CCCGGG	3
	SmiI      ATTTAAAT	4
	SnaBI       TACGTA	3
	SpeI        ACTAGT	1
	SphI        GCATGC	5
	SplI        CGTACG	1
	SrfI      GCCCGGGC	4
	Sse232I   CGCCGGCG	2
	Sse8387I  CCTGCAGG	6
	Sse9I         AATT	0
	SseBI       AGGCCT	3
	SsiI          CCGC	1
	SspDI       GGCGCC	1
	SspI        AATATT	3
	SspMI         CTAG	1
	SstI        GAGCTC	5
	Sth302II      CCGG	2
	StuI        AGGCCT	3
	SwaI      ATTTAAAT	4
	TaiI          ACGT	4
	TaqI          TCGA	1
	TasI          AATT	0
	Tru1I         TTAA	1
	Tru9I         TTAA	1
	TspEI         AATT	0
	TspMI       CCCGGG	1
	Vha464I     CTTAAG	1
	VneI        GTGCAC	1
	VspI        ATTAAT	2
	XbaI        TCTAGA	1
	XhoI        CTCGAG	1
	XmaI        CCCGGG	1
	XmaIII      CGGCCG	1
	XmaJI       CCTAGG	1
	XspI          CTAG	1
	ZraI        GACGTC	3
	ZrmI        AGTACT	3
	Zsp2I       ATGCAT	5
EOF

}

sub _makeREfragments {
    my $fasta = "$ENV{BOWTIE_INDEXES}/$genome.fa";
    die "No $genome.fa found under directory: $ENV{BOWTIE_INDEXES}!\n" unless -e $fasta;
    my $reseq = $opts{enzymeSeq};
    my $hanglen = $opts{overhang};
    $opts{fragments} = "$opts{enzyme}.$genome.fragments.bed" unless $opts{fragments};

    my	$in_file_name = "$fasta";		# input file name
    open  my $in, '<', $in_file_name
        or die  "$0 : failed to open  input file '$in_file_name' : $!\n";
    my	$to_file_name = "$opts{fragments}";		# output file name
    open  my $to, '>', $to_file_name
        or die  "$0 : failed to open  output file '$to_file_name' : $!\n";

    my ($chr, $loci, $start, $count, $seq, $relen, @parts);
    $reseq = uc $reseq;
    $relen = length($reseq);
    while ( <$in> ) {
        chomp;
        if (/^>(\w+)/) {
            if ($chr) {
                @parts = split /$reseq/, $seq;
                # Do not consider the case that the last bases are enzyme!!!
                if (@parts == 1) { # no RE site
                    print {$to} join("\t", $chr, 0, length($seq), "chr_1", 0, '+'), "\n";
                }
                $seq = pop(@parts);
                for (@parts) {
                    $loci += length;
                    print {$to} join("\t", $chr, $start, $loci, "chr_$count", 0, '+'), "\n";
                    $count++;
                    $start = $loci;
                    $loci += $relen;
                }
                print {$to} join("\t", $chr, $start, $loci
                    + length($seq) - $hanglen, "chr_$count", 0, '+'), "\n";
            }
            $chr = $1;
            $seq = '';
            $loci = $hanglen;
            $start = 0;
            $count = 1;
        }
        else {
            $seq .= uc;
        }
    }
    # process the last chr
    @parts = split /$reseq/, $seq;
    # Do not consider the case that the last bases are enzyme!!!
    if (@parts == 1) { # no RE site
        print {$to} join("\t", $chr, 0, length($seq), "chr_1", 0, '+'), "\n";
    }
    $seq = pop(@parts);
    for (@parts) {
        $loci += length;
        print {$to} join("\t", $chr, $start, $loci, "chr_$count", 0, '+'), "\n";
        $count++;
        $start = $loci;
        $loci += $relen;
    }
    print {$to} join("\t", $chr, $start, $loci + length($seq) - $hanglen,
        "chr_$count", 0, '+'), "\n";

    close  $to
        or warn "$0 : failed to close output file '$to_file_name' : $!\n";
    close  $in
        or warn "$0 : failed to close input file '$in_file_name' : $!\n";
}

sub _mapPETsToFragments {
    my $dir = shift;
    my $distance = $opts{distance};
    mkdir "tmp.$$" unless -d "tmp.$$";
    my $pm = Parallel::ForkManager->new( $cpu, "tmp.$$" );
    my ($total, $self, $dangling, $filtered) = (0, 0, 0, 0);
    my %valid = (
        '++' => 0,
        '+-' => 0,
        '--' => 0,
    );
    $pm->run_on_finish(
        sub {
            my ( $pid, $exit_code, $indent, $exit_sig, $core, $data ) = @_;
            die "Map pets to fragments for '$indent.realintra' failed.\n"
              unless $exit_code == 0;
            $total += $data->[0];
            $valid{'++'}  += $data->[1];
            $valid{'+-'}  += $data->[2];
            $valid{'--'}  += $data->[3];
            $self += $data->[4];
            $dangling += $data->[5];
            $filtered += $data->[6];
        }
    );
    my $binsize = 10_000;
    my (%fragments, @t);
    open my $in, '<', $opts{fragments}
        or die "Can't open input file $opts{fragments}!\n";
    while (<$in>) {
        @t = split;
        push @{$fragments{$t[0]}[$t[2] / $binsize]}, $t[2]; # end
    }
    for (keys %fragments) { # add 0 to each chr
        unless (exists $chrs{$_}) { # to free memory
            delete $fragments{$_};
        }
        unshift @{$fragments{$_}[0]}, 0;
    }
    for my $chr (@chrs) { # process intra-pets
        $pm->start("$chr.realintra") and next;
        my @fragments = @{$fragments{$chr}}; # for this chr
        %fragments = (); # to free memory
        open my $in, '<', $opts{fragments}
            or die "Can't open input file $opts{fragments}!\n";
        while (<$in>) {
            @t = split;
            unless ($t[0] eq $chr) {
                last if $#fragments;
                next;
            }
            push @{$fragments[$t[2] / $binsize]}, $t[2]; # end
        }
        close $in;
        open $in, '<', "$chr.realintra"
            or die "Can't open input file $chr.realintra!\n";
        open my $to, '>', "$dir/$chr.realintra"
            or die "Can't open output file $dir/$chr.realintra!\n";
        my (@ends, $index, $i, $start, $end, $loci, $frag1, $frag2, $frag);
        my ($total, $self, $dangling, $filtered) = (0, 0, 0, 0);
        my %valid = (
            '++' => 0,
            '+-' => 0,
            '-+' => 0,
            '--' => 0,
        );
        while (<$in>) {
            @t = split;
            # check the first loci
            $frag = -1; # default values
            $loci = $t[0];
            $index = int($loci / $binsize);
            if ($fragments[$index]) {
                @ends = @{$fragments[$index]};
                if ($loci < $ends[0]) {
                    # find the start of the first fragment
                    $i = $index - 1;
                    $i-- until $fragments[$i];
                    $start = $fragments[$i][-1];
                    if ($loci + $distance > $ends[0] or $loci - $distance < $start) {
                        $frag = $start;
                    }
                }
                elsif ($loci > $ends[-1]) {
                    # find the end of the last fragment
                    $i = $index + 1;
                    $i++ until $fragments[$i];
                    $end = $fragments[$i][0];
                    if ($loci + $distance > $end or $loci - $distance < $ends[-1]) {
                        $frag = $ends[-1];
                    }
                }
                else {
                    for (0 .. $#ends) {
                        if ($loci == $ends[$_]) {
                            $frag = $ends[$_];
                            last;
                        }
                        elsif ($loci < $ends[$_]) {
                            if ($loci - $ends[$_ - 1] < $distance or $ends[$_] - $loci < $distance) {
                                $frag = $ends[$_ - 1];
                            }
                            last;
                        }
                    }
                }
            }
            else { # no RE site in this bin, check nearby bins
                if ($fragments[$index - 1]) { # left side bin
                    if ($loci - $distance < $fragments[$index - 1][-1]) {
                        $frag = $fragments[$index - 1][-1];
                    }
                }
                if ($fragments[$index + 1]) { # right side bin
                    if ($loci + $distance > $fragments[$index + 1][0]) {
                        # find the start of the first fragment
                        $i = $index - 1;
                        $i-- until $fragments[$i];
                        $frag = $fragments[$i][-1];
                    }
                }
            }
            $frag1 = $frag;
            # check the second loci
            $frag = -1; # default values
            $loci = $t[2];
            $index = int($loci / $binsize);
            if ($fragments[$index]) {
                @ends = @{$fragments[$index]};
                if ($loci < $ends[0]) {
                    # find the start of the first fragment
                    $i = $index - 1;
                    $i-- until $fragments[$i];
                    $start = $fragments[$i][-1];
                    if ($loci + $distance > $ends[0] or $loci - $distance < $start) {
                        $frag = $start;
                    }
                }
                elsif ($loci > $ends[-1]) {
                    # find the end of the last fragment
                    $i = $index + 1;
                    $i++ until $fragments[$i];
                    $end = $fragments[$i][0];
                    if ($loci + $distance > $end or $loci - $distance < $ends[-1]) {
                        $frag = $ends[-1];
                    }
                }
                else {
                    for (0 .. $#ends) {
                        if ($loci == $ends[$_]) {
                            $frag = $ends[$_];
                            last;
                        }
                        elsif ($loci < $ends[$_]) {
                            if ($loci - $ends[$_ - 1] < $distance or $ends[$_] - $loci < $distance) {
                                $frag = $ends[$_ - 1];
                            }
                            last;
                        }
                    }
                }
            }
            else { # no RE site in this bin, check nearby bins
                if ($fragments[$index - 1]) { # left side bin
                    if ($loci - $distance < $fragments[$index - 1][-1]) {
                        $frag = $fragments[$index - 1][-1];
                    }
                }
                if ($fragments[$index + 1]) { # right side bin
                    if ($loci + $distance > $fragments[$index + 1][0]) {
                        # find the start of the first fragment
                        $i = $index - 1;
                        $i-- until $fragments[$i];
                        $frag = $fragments[$i][-1];
                    }
                }
            }
            $frag2 = $frag;
            if ($frag1 == -1 and $frag2 == -1) { # both unmapped
                $filtered++;
            }
            elsif ($frag1 == -1 or $frag2 == -1) { # one end unmapped
                $dangling++;
            }
            elsif ($frag1 == $frag2) { # same fragment
                $self++;
            }
            else {
                $valid{"$t[3]$t[4]"}++;
                print {$to} $_;
            }
        }
        $total = $.;
        close $in;
        #unlink "$chr.realintra";
        $valid{'+-'} +=  $valid{'-+'};
        $pm->finish( 0, [$total, $valid{'++'}, $valid{'+-'}, $valid{'--'},
            $self, $dangling, $filtered] );
    }
    for my $chr (@chrs) { # process inter-pets
        $pm->start("$chr.realinter") and next;
        my @fragments = @{$fragments{$chr}}; # for this chr
        delete $fragments{$chr};
        my %valid = (
            '++' => 0,
            '+-' => 0,
            '-+' => 0,
            '--' => 0,
        );
        open my $in, '<', "$chr.realinter"
            or die "Can't open input file $chr.realinter!\n";
        my (@ends, $index, $i, $start, $end, $loci, $frag1, $frag2, $frag);
        open my $to, '>', "$dir/$chr.realinter"
            or die "Can't open output file $dir/$chr.realinter!\n";
        my ($total, $self, $dangling, $filtered) = (0, 0, 0, 0);
        while (<$in>) {
            @t = split;
            # check the first loci
            $frag = -1; # default values
            $loci = $t[0];
            $index = int($loci / $binsize);
            if ($fragments[$index]) {
                @ends = @{$fragments[$index]};
                if ($loci < $ends[0]) {
                    # find the start of the first fragment
                    $i = $index - 1;
                    $i-- until $fragments[$i];
                    $start = $fragments[$i][-1];
                    if ($loci + $distance > $ends[0] or $loci - $distance < $start) {
                        $frag = $start;
                    }
                }
                elsif ($loci > $ends[-1]) {
                    # find the end of the last fragment
                    $i = $index + 1;
                    $i++ until $fragments[$i];
                    $end = $fragments[$i][0];
                    if ($loci + $distance > $end or $loci - $distance < $ends[-1]) {
                        $frag = $ends[-1];
                    }
                }
                else {
                    for (0 .. $#ends) {
                        if ($loci == $ends[$_]) {
                            $frag = $ends[$_];
                            last;
                        }
                        elsif ($loci < $ends[$_]) {
                            if ($loci - $ends[$_ - 1] < $distance or $ends[$_] - $loci < $distance) {
                                $frag = $ends[$_ - 1];
                            }
                            last;
                        }
                    }
                }
            }
            else { # no RE site in this bin, check nearby bins
                if ($fragments[$index - 1]) { # left side bin
                    if ($loci - $distance < $fragments[$index - 1][-1]) {
                        $frag = $fragments[$index - 1][-1];
                    }
                }
                if ($fragments[$index + 1]) { # right side bin
                    if ($loci + $distance > $fragments[$index + 1][0]) {
                        # find the start of the first fragment
                        $i = $index - 1;
                        $i-- until $fragments[$i];
                        $frag = $fragments[$i][-1];
                    }
                }
            }
            $frag1 = $frag;
            # check the second loci
            $frag = -1; # default values
            $loci = $t[2];
            $index = int($loci / $binsize);
            if ($fragments{$t[1]}[$index]) {
                @ends = @{$fragments{$t[1]}[$index]};
                if ($loci < $ends[0]) {
                    # find the start of the first fragment
                    $i = $index - 1;
                    $i-- until $fragments{$t[1]}[$i];
                    $start = $fragments{$t[1]}[$i][-1];
                    if ($loci + $distance > $ends[0] or $loci - $distance < $start) {
                        $frag = $start;
                    }
                }
                elsif ($loci > $ends[-1]) {
                    # find the end of the last fragment
                    $i = $index + 1;
                    $i++ until $fragments{$t[1]}[$i];
                    $end = $fragments{$t[1]}[$i][0];
                    if ($loci + $distance > $end or $loci - $distance < $ends[-1]) {
                        $frag = $ends[-1];
                    }
                }
                else {
                    for (0 .. $#ends) {
                        if ($loci == $ends[$_]) {
                            $frag = $ends[$_];
                            last;
                        }
                        elsif ($loci < $ends[$_]) {
                            if ($loci - $ends[$_ - 1] < $distance or $ends[$_] - $loci < $distance) {
                                $frag = $ends[$_ - 1];
                            }
                            last;
                        }
                    }
                }
            }
            else { # no RE site in this bin, check nearby bins
                if ($fragments{$t[1]}[$index - 1]) { # left side bin
                    if ($loci - $distance < $fragments{$t[1]}[$index - 1][-1]) {
                        $frag = $fragments{$t[1]}[$index - 1][-1];
                    }
                }
                if ($fragments{$t[1]}[$index + 1]) { # right side bin
                    if ($loci + $distance > $fragments{$t[1]}[$index + 1][0]) {
                        # find the start of the first fragment
                        $i = $index - 1;
                        $i-- until $fragments{$t[1]}[$i];
                        $frag = $fragments{$t[1]}[$i][-1];
                    }
                }
            }
            $frag2 = $frag;
            if ($frag1 == -1 and $frag2 == -1) { # both unmapped
                $filtered++;
            }
            elsif ($frag1 == -1 or $frag2 == -1) { # one end unmapped
                $dangling++;
            }
            else {
                $valid{"$t[3]$t[4]"}++;
                print {$to} $_;
            }
        }
        $total = $.;
        close $in;
        close $to;
        #unlink "$chr.realinter";
        $valid{'+-'} +=  $valid{'-+'};
        # inter PETs are duplicated
        $pm->finish( 0, [$total / 2, $valid{'++'} / 2, $valid{'+-'} / 2,
            $valid{'--'} / 2, $self / 2, $dangling / 2, $filtered / 2] );
    }
    $pm->wait_all_children();
    rmdir "tmp.$$" or warn "Can't delete temporary folder tmp.$$. $!\n";
    my $kept = $valid{'++'} + $valid{'+-'} + $valid{'--'};
    my $log = "Map PETs to fragments done! Totally:\n";
    $log .= "    #Total    #Kept    %Ratio\n";
    $log .= sprintf("%9.2fM%9.2fM%9.2f%%\n\n",
        $total / 1_000_000,
        $kept  / 1_000_000,
        $kept  / $total * 100
    );
    $log .=         "       Type    %Ratio\n";
    $log .= sprintf("        #FF%9.2f%%\n", 100 * $valid{'++'} / $total);
    $log .= sprintf("     #FR|RF%9.2f%%\n", 100 * $valid{'+-'} / $total);
    $log .= sprintf("        #RR%9.2f%%\n", 100 * $valid{'--'} / $total);
    $log .= sprintf("      #Self%9.2f%%\n", 100 * $self / $total);
    $log .= sprintf("  #Dangling%9.2f%%\n", 100 * $dangling / $total);
    $log .= sprintf("  #Filtered%9.2f%%\n", 100 * $filtered / $total);
    _logging($log);
}

sub _makeGenomeBins {
    my $output = shift;
    my $binsize = $opts{binsize};
    my $number = 0;
    open my $in, '<', $chromSizesFile
        or die "Can't open input file $chromSizesFile. $!\n";
    my %chromSizes = map {split} <$in>;
    close $in;
    open my $to, '>', $output or die "Can't open output file $output. $!\n";
    for my $chr (@chrs) {
        my $max = $chromSizes{$chr};
        my $start;
        for (0 .. $max / $binsize - 1) {
            $start = $_ * $binsize;
            print {$to} join("\t", $chr, $start, $start + $binsize, $number++), "\n";
        }
        $start = int($max / $binsize) * $binsize;
        print {$to} join("\t", $chr, $start, $max, $number++), "\n";
    }
    close $to;
}

sub _makeGenomicMatrix {
    my $output = shift;
    my $binsize = $opts{binsize};
    open my $in, '<', $chromSizesFile or die "Can't open input file $chromSizesFile. $!\n";
    my %chromSizes = map {split} <$in>;
    close $in;
    my %baseIndex;
    my $number = 0;
    for my $chr (@chrs) {
        $baseIndex{$chr} = $number;
        $number += int($chromSizes{$chr} / $binsize) + 1;
    }
    my $pm = Parallel::ForkManager->new( $cpu );
    $pm->run_on_finish(
        sub {
            my ( $pid, $exit_code, $indent ) = @_;
            die "Generate interaction matrix for '$indent' failed.\n"
              unless $exit_code == 0;
        }
    );
    my (@t, $index1, $index2);
    for my $chr (@chrs) {
        $pm->start("$chr.realintra") and next;
        my %count;
        open $in, '<', "$chr.realintra"
            or die "Can't open input file $chr.realintra. $!\n";
        while (<$in>) {
            @t = split;
            $index1 = int($t[0] / $binsize);
            $index2 = int($t[2] / $binsize);
            $count{$index1}{$index2}++;
        }
        close $in;
        open my $to, '>', "$chr.realintra.matrix"
            or die "Can't open output file $chr.realintra.matrix. $!\n";
        for my $index1 (sort {$a <=> $b} keys %count) {
            for my $index2 (sort {$a <=> $b} keys %{$count{$index1}}) {
                print {$to} join("\t", $index1 + $baseIndex{$chr},
                    $index2 + $baseIndex{$chr}, $count{$index1}{$index2}), "\n";
            }
        }
        close $to;
        $pm->finish;
    }
    for my $chr (@chrs) {
        $pm->start("$chr.realinter") and next;
        my %count;
        open $in, '<', "$chr.realinter"
            or die "Can't open input file $chr.realinter. $!\n";
        while (<$in>) {
            @t = split;
            next if $t[1] lt $chr;
            $index1 = int($t[0] / $binsize);
            $index2 = int($t[2] / $binsize);
            $count{$index1}{$index2 + $baseIndex{$t[1]}}++;
        }
        close $in;
        open my $to, '>', "$chr.realinter.matrix"
            or die "Can't open output file $chr.realinter.matrix. $!\n";
        for my $index1 (sort {$a <=> $b} keys %count) {
            for my $index2 (sort {$a <=> $b} keys %{$count{$index1}}) {
                print {$to} join("\t", $index1 + $baseIndex{$chr},
                    $index2, $count{$index1}{$index2}), "\n";
            }
        }
        close $to;
        $pm->finish;
    }
    $pm->wait_all_children;
    my $cmd = "cat ";
    for my $chr (@chrs) {
        $cmd .= "$chr.realintra.matrix $chr.realinter.matrix ";
    }
    $cmd .= "> $output";
    system($cmd) == 0 or die "CMD: $cmd failed!";
    for my $chr (@chrs) {
        unlink "$chr.realintra.matrix", "$chr.realinter.matrix";
    }
}

sub _iceNormalization {
    my ($input, $output) = @_;
    my $eps = $opts{eps} || 0.1;
    my $lowpec = $opts{lowpec} || 0.02;
    my $highpec = $opts{highpec} || 0;
    my $maxiter = $opts{maxiter} || 100;
    my $cmd = "ice -r $output --filter_low_counts_perc $lowpec "
        . "--filter_high_counts_perc $highpec -m $maxiter --eps $eps $input";
    $cmd .= ' --dense' if $opts{dense};
    system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
}

sub _genomicMatrixToWashU {
    my (@idToRegion, @t, @region);
    open my $in, '<', $opts{regionbed} or die "Can't open file $opts{regionbed}. $!";
    open my $to, '>', $opts{output} or die "Can't open file $opts{output}. $!";
    my $counts = $opts{counts}; # number of counts after scaling
    if ($opts{bgzip}) { # output in BED6 format
        my $line = <$in>;
        @t = split /\s+/, $line;
        $idToRegion[$t[-1]] = [@t[0, 1, 2]];
        my $binsize = $t[2] - $t[1];
        while (<$in>) {
            @t = split;
            $idToRegion[$t[-1]] = [@t[0, 1, 2]];
        }
        close $in;
        open $in, '<', $opts{rawmatrix} or die "Can't open file $opts{rawmatrix}. $!";
        my $totalCounts;
        while (<$in>) {
            @t = split;
            $totalCounts += $t[2];
        }
        close $in;
        $counts /= $totalCounts; # scaling factor
        open $in, '<', $opts{rawmatrix} or die "Can't open file $opts{rawmatrix}. $!";
        my $maxbins = int($opts{maxdistance} / $binsize);
        while (<$in>) {
            @t = split;
            next if $t[1] - $t[0] > $maxbins or $t[1] == $t[0];
            $t[2] = sprintf("%.1f", $t[2] * $counts);
            @region = @{$idToRegion[$t[1]]};
            print {$to} join("\t", @{$idToRegion[$t[0]]},
                "$region[0]:$region[1]-$region[2],$t[2]", $. * 2 - 1, '.'), "\n";
            @region = @{$idToRegion[$t[0]]};
            print {$to} join("\t", @{$idToRegion[$t[1]]},
                "$region[0]:$region[1]-$region[2],$t[2]", $. * 2, '.'), "\n";
        }
        close $in;
        close $to;
        my $cmd = "bedSort $opts{output} $opts{output}";
        system($cmd) == 0 or die "CMD: $cmd failed. $!";
        $cmd = "bgzip -f $opts{output}";
        system($cmd) == 0 or die "CMD: $cmd failed. $!";
        $cmd = "tabix -p bed -f $opts{output}.gz";
        system($cmd) == 0 or die "CMD: $cmd failed. $!";
    }
    else { # output in TXT format
        while (<$in>) {
            @t = split;
            $idToRegion[$t[-1]] = join(',', @t[0, 1, 2]);
        }
        close $in;
        open $in, '<', $opts{rawmatrix} or die "Can't open file $opts{rawmatrix}. $!";
        my $binsize = $t[2] - $t[1];
        my $maxbins = int($opts{maxdistance} / $binsize);
        my $totalCounts;
        while (<$in>) {
            @t = split;
            $totalCounts += $t[2];
        }
        close $in;
        $counts /= $totalCounts; # scaling factor
        open $in, '<', $opts{rawmatrix} or die "Can't open file $opts{rawmatrix}. $!";
        while (<$in>) {
            @t = split;
            next if $t[1] - $t[0] > $maxbins;
            $t[2] = sprintf("%.1f", $t[2] * $counts);
            print {$to} join("\t", $idToRegion[$t[0]], $idToRegion[$t[1]], $t[2]), "\n";
        }
        close $in;
        close $to;
    }
}

sub _petsToWashU {
    my ($binsize, $maxdistance, $output, $background) = @_;
    my $count = 0;
    open my $to, '>', $output or die "Can't create file $output. $!\n";
    while (my ($chr, $size) = each %chrs) {
        next unless -e "$chr.realintra";
        $maxdistance = $size if $maxdistance == 0;
        my (@matrix, $index1, $index2, @t);
        my $start = 0;
        open my $in, '<', "$chr.realintra"
            or die "Can't open file $chr.realintra. $!\n";
        while (<$in>) { # already sorted by start site
            @t = split;
            next unless $t[2] - $t[0] < $maxdistance;
            $index1 = $t[0] / $binsize;
            $index2 = ($t[2] - $t[0]) / $binsize;
            $matrix[$index1][$index2]++;
        }
        close $in;
        my $regionLen = $maxdistance / $binsize - 1;
        my $start1 = 0;
        my ($end1, $start2, $end2, @scores);
        for (@matrix) {
            unless ($_) { # if undefined
                $start1 += $binsize;
                next;
            }
            @scores = @$_;
            $end1 = $start1 + $binsize;
            last if $end1 > $size;
            for my $j (1 .. $regionLen) {
                next unless $scores[$j] and $scores[$j] > $background;
                $start2 = $start1 + $j * $binsize;
                $end2 = $start2 + $binsize;
                $end2 = $size if $end2 > $size;
                print {$to} join("\t", "$chr", $start1, $end1,
                    "$chr:$start2-$end2,$scores[$j]", $count++, '.'), "\n";
                print {$to} join("\t", "$chr", $start2, $end2,
                    "$chr:$start1-$end1,$scores[$j]", $count++, '.'), "\n";
            }
            $start1 += $binsize;
        }
    }
    close $to;
}

sub _petsToWashUChr {
    my ($chr, $binsize, $maxdistance, $output, $background) = @_;
    my $count = 0;
    open my $to, '>', $output or die "Can't create file $output. $!\n";
    my $size = $chrs{$chr} or die "$chr is not existed in $genome!\n";
    die "$chr.realintra not exists!\n" unless -e "$chr.realintra";
    my (@matrix, $index1, $index2, @t);
    my $start = 0;
    open my $in, '<', "$chr.realintra"
        or die "Can't open file $chr.realintra. $!\n";
    while (<$in>) { # already sorted by start site
        @t = split;
        next unless $t[2] - $t[0] < $maxdistance;
        $index1 = $t[0] / $binsize;
        $index2 = ($t[2] - $t[0]) / $binsize;
        $matrix[$index1][$index2]++;
    }
    close $in;
    my $regionLen = $maxdistance / $binsize - 1;
    my $start1 = 0;
    my ($end1, $start2, $end2, @scores);
    for (@matrix) {
        unless ($_) { # if undefined
            $start1 += $binsize;
            next;
        }
        @scores = @$_;
        $end1 = $start1 + $binsize;
        last if $end1 > $size;
        for my $j (1 .. $regionLen) {
            next unless $scores[$j] and $scores[$j] > $background;
            $start2 = $start1 + $j * $binsize;
            $end2 = $start2 + $binsize;
            $end2 = $size if $end2 > $size;
            print {$to} join("\t", "$chr", $start1, $end1,
                "$chr:$start2-$end2,$scores[$j]", $count++, '.'), "\n";
            print {$to} join("\t", "$chr", $start2, $end2,
                "$chr:$start1-$end1,$scores[$j]", $count++, '.'), "\n";
        }
        $start1 += $binsize;
    }
    close $to;
}

sub _calcDomainIndexes_unused {
    my ($maxDistance, $output) = @_;
    my $pm = Parallel::ForkManager->new( $cpu );
    for my $chr (@chrs) {
        $pm->start() and next;
        open my $in, '<', "$chr.intramatrix" or die "Can't open file $chr.intramatrix. $!\n";
        my $head = <$in>;
        my @positions = split /\s+/, $head;
        my $resolution = $positions[2] - $positions[1];
        my $size = int($maxDistance / $resolution);
        my $max = $#positions;
        my (@DIs, @t, $left, $right, $sumLeft, $sumRight);
        while (<$in>) {
            @t = split;
            $left = $. - $size;
            $left = 1 if $left < 1;
            $right = $. + $size;
            $right = $max if $right > $max;
            $sumLeft = sum(@t[$left .. $.-2]) || 0;
            $sumRight = sum(@t[$. .. $right]) || 0;
            if ($sumLeft == $sumRight or $sumLeft * $sumRight == 0) {
                push @DIs, 0;
            }
            elsif ($sumLeft < $sumRight) {
                push @DIs, ($sumRight - $sumLeft) ** 2 / ($sumRight + $sumLeft);
            }
            else {
                push @DIs, -($sumRight - $sumLeft) ** 2 / ($sumRight + $sumLeft);
            }
        }
        close $in;
        @DIs = map {int} @DIs;
        open my $to, '>', "$chr.DIs";
        my $value;
        for (0 .. $#DIs) {
            print {$to} join("\t", $chr, $_ * $resolution, ($_ + 1) * $resolution, $DIs[$_]), "\n";
        }
        close $to;
#        my (@forward, @reverse);
#        my @selected = sort {$a <=> $b} grep {$_ > 0} @DIs;
#        my $cutoff1 = $selected[$#selected * 0.3];
#        @selected = sort {$a <=> $b} grep {$_ < 0} @DIs;
#        my $cutoff2 = $selected[$#selected * 0.7];
#        my $sum = 0;
#        for (0 .. $#DIs) {
#            if ($DIs[$_] < $cutoff2) {
#                $sum += $DIs[$_];
#            }
#            else {
#                $sum = 0;
#            }
#            push @forward, $sum;
#        }
#        $sum = 0;
#        for (reverse 0 .. $#DIs) {
#            if ($DIs[$_] > $cutoff1) {
#                $sum += $DIs[$_];
#            }
#            else {
#                $sum = 0;
#            }
#            push @reverse, $sum;
#        }
#        @reverse = reverse @reverse;
#        open my $to, '>', "$chr.DIs";
#        my $value;
#        for (0 .. $#forward) {
#            $value = abs($forward[$_]) > abs($reverse[$_]) ? $forward[$_] : $reverse[$_];
#            print {$to} join("\t", $chr, $_ * $resolution, ($_ + 1) * $resolution, int($value)), "\n";
#        }
#        close $to;
        $pm->finish;
    }
    $pm->wait_all_children;
    my $cmd1 = 'cat ';
    my $cmd2 = 'rm ';
    for my $chr (@chrs) {
        $cmd1 .= "$chr.DIs ";
        $cmd2 .= "$chr.DIs ";
    }
    $cmd1 .= "> $output";
    system($cmd1) == 0 or die "CMD: $cmd1 failed. $!\n";
    system($cmd2) == 0 or die "CMD: $cmd2 failed. $!\n";
}

sub _calcDomainIndexes {
    my ($binsize, $maxdistance, $output) = @_;
    open my $to, '>', $output or die "Can't create file $output. $!\n";
    while (my ($chr, $size) = each %chrs) {
        next unless -e "$chr.realintra";
        my (@matrix, $index1, $index2, @t);
        open my $in, '<', "$chr.realintra"
            or die "Can't open file $chr.realintra. $!\n";
        while (<$in>) { # already sorted by start site
            @t = split;
            next if $t[2] - $t[0] > $maxdistance;
            $index1 = int($t[0] / $binsize);
            $index2 = int($t[2] / $binsize);
            next if $index1 == $index2; # the same bin
            $matrix[$index1][1]++; # 1 means right
            $matrix[$index2][0]++; # 0 means left
        }
        close $in;
        my (@scores, $A, $B, $DI, $start, $end);
        my $index = -1;
        for (@matrix) { # ref: Nature 2012, 485:376-380.
            $index++;
            $start = $index * $binsize;
            $end = $start + $binsize;
            $end = $size if $end > $size;
            unless ($_) {
                print {$to} join("\t", $chr, $start, $end, 0), "\n";
                next;
            }
            @scores = @$_;
            $A = $scores[0] || 0;
            $B = $scores[1] || 0;
            if ($A == $B) {
                print {$to} join("\t", $chr, $start, $end, 0), "\n";
                next;
            }
            $DI = ($A - $B) ** 2 / ($A + $B);
            $DI = -$DI if $B < $A;
            print {$to} join("\t", $chr, $start, $end, sprintf("%.2f", $DI)), "\n";
        }
    }
    close $to;
}

sub _bgzipFile {
    my $file = shift;
    my $cmd = "bedSort $file $file";
    system($cmd) == 0 or die "CMD: $cmd failed!\n";
    $cmd = "bgzip -f $file";
    system($cmd) == 0 or die "CMD: $cmd failed!\n";
    $cmd = "tabix -p bed -f $file.gz";
    system($cmd) == 0 or die "CMD: $cmd failed!\n";
}

sub _makeInterMatrix {
    my ($binsize, $prefix) = @_;
    my $pm = Parallel::ForkManager->new($cpu);
    for my $chr1 (@chrs) {
        next unless -e "$chr1.realinter";
        for my $chr2 (@chrs) {
            next unless -e "$chr2.realinter";
            next unless $chr1 lt $chr2;
            $pm->start("$chr1,$chr2") and next;
            my (@matrix, $index1, $index2, @t);
            my $base = 0;
            my $maxIndex1 = int($chrs{$chr1} / $binsize);
            my $maxIndex2 = int($chrs{$chr2} / $binsize);
            open my $in, '<', "$chr1.realinter"
                or die "Can't open file $chr1.realinter. $!\n";
            open my $to, '>', "$prefix/$chr1.vs.$chr2.intermatrix"
                or die "$prefix/$chr1.vs.$chr2.intermatrix. $!\n";
            print {$to} join("\t",
                'position', map {$_ * $binsize} 0 .. $maxIndex2), "\n";
            while (<$in>) { # already sorted by start site
                @t = split;
                next unless $t[1] eq $chr2;
                $index1 = int($t[0] / $binsize);
                $index2 = $t[2] / $binsize;
                $matrix[$index1][$index2]++;
                $matrix[$index2][$index1]++;
                if ($index1 > $base) {
                    for ($base .. $index1 - 1) {
                        if ($matrix[$_]) {
                            @t = @{$matrix[$_]};
                            $matrix[$_] = undef; # empty it to free memory
                            @t = map {$t[$_] or 0} 0 .. $maxIndex2;
                        }
                        else { # no interaction for this region
                            @t = map {0} 0 .. $maxIndex2;
                        }
                        print {$to} join("\t", $_ * $binsize, @t), "\n";
                    }
                    $base = $index1;
                }
            }
            close $in;
            for ($base .. $maxIndex1) {
                if ($matrix[$_]) {
                    @t = @{$matrix[$_]};
                    @t = map {$t[$_] or 0} 0 .. $maxIndex2;
                }
                else { # no interaction for this region
                    @t = map {0} 0 .. $maxIndex2;
                }
                print {$to} join("\t", $_ * $binsize, @t), "\n";
            }
            close $to;
            $pm->finish;
        }
    }
    $pm->wait_all_childs;
    for my $chr1 (sort keys %chrs) {
        for my $chr2 (sort keys %chrs) {
            next unless $chr2 gt $chr1;
            $pm->start("$chr2,$chr1") and next;
                _transposeMatrix("$prefix/$chr1.vs.$chr2.intermatrix",
                    "$prefix/$chr2.vs.$chr1.intermatrix");
            $pm->finish;
        }
    }
    $pm->wait_all_childs;
}

sub _transposeMatrix {
    my ($fin, $fto) = @_;
    my @matrix;
    open my $in, '<', $fin or die "Can't open file $fin. $!\n";
    my $head = <$in>;
    chomp($head);
    my @t = split /\t/, $head;
    my @indexes = 0 .. $#t;
    pairwise {push @{$matrix[$a]}, $b} @indexes, @t;
    while (<$in>) {
        chomp;
        @t = split /\t/;
        pairwise {push @{$matrix[$a]}, $b} @indexes, @t;
    }
    close $in;
    open my $to, '>', $fto or die "$fto. $!\n";
    for (@matrix) {
        print {$to} join("\t", @$_), "\n";
    }
    close $to;
}

sub _makeIntraMatrix {
    my ($binsize, $prefix) = @_;
    my $pm = Parallel::ForkManager->new($cpu);
    while (my ($chr, $size) = each %chrs) {
        next unless -e "$chr.realintra";
        $pm->start($chr) and next;
        my (@matrix, $index1, $index2, @t);
        my $base = 0;
        my $maxIndex = int($size / $binsize);
        open my $in, '<', "$chr.realintra"
            or die "Can't open file $chr.realintra. $!\n";
        open my $to, '>', "$prefix/$chr.intramatrix"
            or die "Can't create file $prefix/$chr.intramatrix. $!\n";
        print {$to} join("\t",
            'position', map {$_ * $binsize} 0 .. $maxIndex), "\n";
        while (<$in>) { # already sorted by start site
            @t = split;
            $index1 = int($t[0] / $binsize);
            $index2 = int($t[2] / $binsize);
            next if $index2 == $index1; # the same bin
            $matrix[$index1][$index2]++;
            $matrix[$index2][$index1]++;
            if ($index1 > $base) {
                for ($base .. $index1 - 1) {
                    if ($matrix[$_]) {
                        @t = @{$matrix[$_]};
                        $matrix[$_] = undef; # empty it to free memory
                        @t = map {$t[$_] or 0} 0 .. $maxIndex;
                    }
                    else { # no interaction for this region
                        @t = map {0} 0 .. $maxIndex;
                    }
                    print {$to} join("\t", $_ * $binsize, @t), "\n";
                }
                $base = $index1;
            }
        }
        close $in;
        for ($base .. $maxIndex) {
            if ($matrix[$_]) {
                @t = @{$matrix[$_]};
                @t = map {$t[$_] or 0} 0 .. $maxIndex;
            }
            else { # no interaction for this region
                @t = map {0} 0 .. $maxIndex;
            }
            print {$to} join("\t", $_ * $binsize, @t), "\n";
        }
        close $to;
        $pm->finish;
    }
    $pm->wait_all_childs;
}

sub _calcIntraMatrixPCC {
    my ($dir1, $dir2, $output, $cutoff) = @_;
    my $pm = Parallel::ForkManager->new($cpu);
    require Statistics::R;
    my %pcc;
    $pm->run_on_finish(
        sub {
            my ( $pid, $exit_code, $indent, $exit_sig, $core, $data ) = @_;
            die "Calculate PCC for '$indent.realintra' failed.\n"
              unless $exit_code == 0;
            $pcc{$data->[0]} = $data->[1];
        }
    );
    for my $chr (@chrs) {
        $pm->start($chr) and next;
        my $pcc = 0;
        unless (-e "$dir1/$chr.realintra.matrix" and -e "$dir2/$chr.realintra.matrix") {
            print "File '$dir1/$chr.realintra.matrix' not exists!\n"
                unless -e "$dir1/$chr.realintra.matrix";
            print "File '$dir2/$chr.realintra.matrix' not exists!\n"
                unless -e "$dir2/$chr.realintra.matrix";
            $pm->finish(0, [$chr, $pcc]);
        }
        my (%data, $in, @t, $data1, $data2, @data);
        open $in, '<', "$dir1/$chr.realintra.matrix";
        while (<$in>) {
            @t = split;
            next if $t[2] < $cutoff;
            $data{$t[0]}{$t[1]} = $t[2];
        }
        close $in;
        $data1 = 'c(';
        $data2 = 'c(';
        open $in, '<', "$dir2/$chr.realintra.matrix";
        while (<$in>) {
            @t = split;
            next if $t[2] < $cutoff;
            if (exists $data{$t[0]}) {
                if (exists $data{$t[0]}{$t[1]}) {
                    $data1 .= "$data{$t[0]}{$t[1]},";
                    delete $data{$t[0]}{$t[1]};
                }
                else {
                    $data1 .= "0,";
                }
            }
            else {
                $data1 .= "0,";
            }
            $data2 .= "$t[2],";
        }
        close $in;
        while (my ($id, $ref) = each %data) {
            @data = values %$ref;
            next unless @data;
            $data1 .= join(',', @data) . ',';
            $data2 .= '0,' x scalar(@data);
        }
        chop($data1); # chop the ending ','
        chop($data2); # chop the ending ','
        $data1 .= ')';
        $data2 .= ')';
        my $Rcode = "pcc <- cor($data1, $data2)";
        my $R = Statistics::R->new();
        $R->run($Rcode);
        $pcc = $R->get('pcc');
        $pm->finish(0, [$chr, $pcc]);
    }
    $pm->wait_all_childs();

    open my $to, '>', $opts{output};
    for (@chrs) {
        print {$to} "$_\t$pcc{$_}\n";
    }
    close $to;
}

sub _cluster {
    my ( $pets_file, $Eps, $MinPts, $out, $chr, $chrSizeRef, $distance ) = @_;
    my ( %pets, %tag_num, %sta_end );
    open my $fout, '>', $out       or die "Can't create $out. $!\n";
    open my $fin,  '<', $pets_file or die "$pets_file $!\n";
    my (@store, @pets, $number, $end, @new, @new1, @t, $type);
    while (<$fin>) {
        @t = split;
        next if $t[2] - $t[0] < $distance;
        if ( $t[0] - ( $sta_end{ $t[1] } or $t[0] ) <= $Eps )
        {    # filter using start sites
            push @{ $pets{ $t[1] } }, [ @t[ 0, 2 ] ];    # use chrID as keys
            $sta_end{ $t[1] } = $t[0];
            $tag_num{ $t[1] }++;
        }
        else {    # gap for start sites
            if ( $tag_num{ $t[1] } >= $MinPts ) {
                @pets = sort { $a->[1] <=> $b->[1] } @{ $pets{ $t[1] } };
                @store = ([1, @pets]); # 0 means sorted by start, 1 means end
                while (@store) {
                    @pets = @{+pop @store};
                    $type = shift @pets;
                    next if @pets < $MinPts;
                    $number = @pets;
                    if ($type == 1) { # already sorted by end sites
                        # filter using end sites
                        @new = (shift @pets);
                        $end = $new[0][1];
                        while (@pets) {
                            if ( $pets[0][1] - $end <= $Eps ) {
                                $end = $pets[0][1];
                                push @new, shift @pets;
                            }
                            else { # gap for end sites
                                if (@new < $MinPts) { # useless, throw away and check next
                                    @new = (shift @pets);
                                    $end = $new[0][1];
                                    next;
                                }
                                push @store, [1, @pets] unless @pets < $MinPts;
                                last;
                            }
                        }
                        next if @new < $MinPts; # when @pets is empty
                        if (@new == $number) { # end site didn't filter any pet
                            if ($number > 100) { # filter using start sites again
                                @pets = sort { $a->[0] <=> $b->[0] } @new;
                                @new = (shift @pets);
                                $end = $new[0][0];
                                while (@pets) {
                                    if ( $pets[0][0] - $end <= $Eps ) {
                                        $end = $pets[0][0];
                                        push @new, shift @pets;
                                    }
                                    else { # gap for start sites
                                        if (@new < $MinPts) { # useless, throw away and check next
                                            @new = (shift @pets);
                                            $end = $new[0][0];
                                            next;
                                        }
                                        push @store, [0, @pets] unless @pets < $MinPts;
                                        last;
                                    }
                                }
                                next if @new < $MinPts; # when @pets is empty
                                if (@new == $number) { # start site didn't filter any pet
                                    _searchInteraction( \@new, $Eps, $MinPts, $fout, $chr, $t[1], $chrSizeRef, 0 );
                                    next;
                                }
                                @new = sort { $a->[1] <=> $b->[1] } @new;
                                push @store, [1, @new]; # go on filter
                                next;
                            }
                            _searchInteraction( \@new, $Eps, $MinPts, $fout, $chr, $t[1], $chrSizeRef, 1 );
                            next;
                        }
                        @new = sort { $a->[0] <=> $b->[0] } @new;
                        push @store, [0, @new]; # go on filter
                    }
                    else { # already sorted by start sites
                        # filter using start sites
                        @new = (shift @pets);
                        $end = $new[0][0];
                        while (@pets) {
                            if ( $pets[0][0] - $end <= $Eps ) {
                                $end = $pets[0][0];
                                push @new, shift @pets;
                            }
                            else { # gap for start sites
                                if (@new < $MinPts) { # useless, throw away and check next
                                    @new = (shift @pets);
                                    $end = $new[0][0];
                                    next;
                                }
                                push @store, [0, @pets] unless @pets < $MinPts;
                                last;
                            }
                        }
                        next if @new < $MinPts; # when @pets is empty
                        if (@new == $number) { # start site didn't filter any pet
                            if ($number > 100) { # filter using end sites again
                                @pets = sort { $a->[1] <=> $b->[1] } @new;
                                @new = (shift @pets);
                                $end = $new[0][1];
                                while (@pets) {
                                    if ( $pets[0][1] - $end <= $Eps ) {
                                        $end = $pets[0][1];
                                        push @new, shift @pets;
                                    }
                                    else { # gap for end sites
                                        if (@new < $MinPts) { # useless, throw away and check next
                                            @new = (shift @pets);
                                            $end = $new[0][1];
                                            next;
                                        }
                                        push @store, [1, @pets] unless @pets < $MinPts;
                                        last;
                                    }
                                }
                                next if @new < $MinPts; # when @pets is empty
                                if (@new == $number) { # end site didn't filter any pet
                                    _searchInteraction( \@new, $Eps, $MinPts, $fout, $chr, $t[1], $chrSizeRef, 1 );
                                    next;
                                }
                                @new = sort { $a->[1] <=> $b->[1] } @new;
                                push @store, [1, @new]; # go on filter
                                next;
                            }
                            _searchInteraction( \@new, $Eps, $MinPts, $fout, $chr, $t[1], $chrSizeRef, 0 );
                            next;
                        }
                        @new = sort { $a->[1] <=> $b->[1] } @new;
                        push @store, [1, @new]; # go on filter
                    }
                }
            }
            undef( $pets{ $t[1] } );
            push @{ $pets{ $t[1] } }, [ @t[ 0, 2 ] ];    # use chrID as keys
            $sta_end{ $t[1] } = $t[0];
            $tag_num{ $t[1] } = 1;
        }
    }
    close $fin;
    # process last part of %pets
    while ( my ( $k, $v ) = each %pets ) {
        if ( $tag_num{$k} >= $MinPts ) {
            @pets = sort { $a->[1] <=> $b->[1] } @$v;
            @store = [1, @pets]; # 0 means sorted by start, 1 means end
            while (@store) {
                @pets = @{+pop @store};
                $type = shift @pets;
                $number = @pets;
                if ($type == 1) { # already sorted by end sites
                    # filter using end sites
                    @new = (shift @pets);
                    $end = $new[0][1];
                    while (@pets) {
                        if ( $pets[0][1] - $end <= $Eps ) {
                            $end = $pets[0][1];
                            push @new, shift @pets;
                        }
                        else { # gap for end sites
                            if (@new < $MinPts) { # useless, throw away and check next
                                @new = (shift @pets);
                                $end = $new[0][1];
                                next;
                            }
                            push @store, [1, @pets] unless @pets < $MinPts;
                            last;
                        }
                    }
                    next if @new < $MinPts; # when @pets is empty
                    if (@new == $number) { # end site didn't filter any pet
                        if ($number > 100) { # filter using start sites again
                            @pets = sort { $a->[0] <=> $b->[0] } @new;
                            @new = (shift @pets);
                            $end = $new[0][0];
                            while (@pets) {
                                if ( $pets[0][0] - $end <= $Eps ) {
                                    $end = $pets[0][0];
                                    push @new, shift @pets;
                                }
                                else { # gap for start sites
                                    if (@new < $MinPts) { # useless, throw away and check next
                                        @new = (shift @pets);
                                        $end = $new[0][0];
                                        next;
                                    }
                                    push @store, [0, @pets] unless @pets < $MinPts;
                                    last;
                                }
                            }
                            next if @new < $MinPts; # when @pets is empty
                            if (@new == $number) { # start site didn't filter any pet
                                _searchInteraction( \@new, $Eps, $MinPts, $fout, $chr, $k, $chrSizeRef, 0 );
                                next;
                            }
                            @new = sort { $a->[1] <=> $b->[1] } @new;
                            push @store, [1, @new]; # go on filter
                            next;
                        }
                        _searchInteraction( \@new, $Eps, $MinPts, $fout, $chr, $k, $chrSizeRef, 1 );
                        next;
                    }
                    @new = sort { $a->[0] <=> $b->[0] } @new;
                    push @store, [0, @new]; # go on filter
                }
                else { # already sorted by start sites
                    # filter using start sites
                    @new = (shift @pets);
                    $end = $new[0][0];
                    while (@pets) {
                        if ( $pets[0][0] - $end <= $Eps ) {
                            $end = $pets[0][0];
                            push @new, shift @pets;
                        }
                        else { # gap for start sites
                            if (@new < $MinPts) { # useless, throw away and check next
                                @new = (shift @pets);
                                $end = $new[0][0];
                                next;
                            }
                            push @store, [0, @pets] unless @pets < $MinPts;
                            last;
                        }
                    }
                    next if @new < $MinPts; # when @pets is empty
                    if (@new == $number) { # start site didn't filter any pet
                        if ($number > 100) { # filter using end sites again
                            @pets = sort { $a->[1] <=> $b->[1] } @new;
                            @new = (shift @pets);
                            $end = $new[0][1];
                            while (@pets) {
                                if ( $pets[0][1] - $end <= $Eps ) {
                                    $end = $pets[0][1];
                                    push @new, shift @pets;
                                }
                                else { # gap for end sites
                                    if (@new < $MinPts) { # useless, throw away and check next
                                        @new = (shift @pets);
                                        $end = $new[0][1];
                                        next;
                                    }
                                    push @store, [1, @pets] unless @pets < $MinPts;
                                    last;
                                }
                            }
                            next if @new < $MinPts; # when @pets is empty
                            if (@new == $number) { # end site didn't filter any pet
                                _searchInteraction( \@new, $Eps, $MinPts, $fout, $chr, $k, $chrSizeRef, 1 );
                                next;
                            }
                            @new = sort { $a->[1] <=> $b->[1] } @new;
                            push @store, [1, @new]; # go on filter
                            next;
                        }
                        _searchInteraction( \@new, $Eps, $MinPts, $fout, $chr, $k, $chrSizeRef, 0 );
                        next;
                    }
                    @new = sort { $a->[1] <=> $b->[1] } @new;
                    push @store, [1, @new]; # go on filter
                }
            }
        }
    }
    close $fout;
    # sort output according to start read position
    my $in_file_name = $out;            # input file name
    open my $in, '<', $in_file_name
      or die "$0 : failed to open  input file '$in_file_name' : $!\n";
    my @clusters;
    while (<$in>) {
        push @clusters, [split];
    }
    close $in
      or warn "$0 : failed to close input file '$in_file_name' : $!\n";
    @clusters = sort { $a->[1] <=> $b->[1] or $a->[2] <=> $b->[2]} @clusters;
    my $to_file_name = $out;    # output file name
    open my $to, '>', $to_file_name
      or die "$0 : failed to open  output file '$to_file_name' : $!\n";
    for (@clusters) {
        print {$to} join( "\t", @$_ ), "\n";
    }
    close $to
      or warn "$0 : failed to close output file '$to_file_name' : $!\n";
}

sub _searchInteraction {
    my ($points_ref, $Eps, $MinPts, $to, $chr1, $chr2, $chrSizeRef, $type) = @_;
    my %chrSize = %$chrSizeRef;
    my $halfEps = int($Eps / 2);
    # turn PETs into single PETs clusters
    my @clusters = map {[$_->[0] - $halfEps, $_->[0] + $halfEps,
        $_->[1] - $halfEps, $_->[1] + $halfEps, 1]} @$points_ref;
    my @merged;
    if ($type == 1) { # sorted by end sites
        while (@clusters > 1) { # merge clusters
            @merged = ();
            for my $i (0 .. $#clusters) {
                next unless $clusters[$i][4]; # already be merged
                for my $j ($i + 1 .. $#clusters) {
                    next unless $clusters[$j][4]; # already be merged
                    if ($clusters[$i][3] < $clusters[$j][2]) { # gap
                        last;
                    }
                    # second regions are overlapped, check first regions
                    unless ($clusters[$i][0] > $clusters[$j][1] or
                        $clusters[$i][1] < $clusters[$j][0]) { # overlapped
                        $clusters[$i][0] = $clusters[$j][0]
                            if $clusters[$i][0] > $clusters[$j][0];
                        $clusters[$i][1] = $clusters[$j][1]
                            if $clusters[$i][1] < $clusters[$j][1];
                        # update end site for second region
                        $clusters[$i][3] = $clusters[$j][3]
                            if $clusters[$i][3] < $clusters[$j][3];
                        $clusters[$i][4] += $clusters[$j][4];
                        $clusters[$j][4] = 0;
                    }
                }
                push @merged, $clusters[$i];
            }
            if (@merged == @clusters) {
                @clusters = @merged;
                last;
            }
            # sort merged clusters by end sites again
            @clusters = sort {$a->[2] <=> $b->[2]} @merged;
        }
    }
    else { # sorted by start sites
        while (@clusters > 1) { # merge clusters
            @merged = ();
            for my $i (0 .. $#clusters) {
                next unless $clusters[$i][4]; # already be merged
                for my $j ($i + 1 .. $#clusters) {
                    next unless $clusters[$j][4]; # already be merged
                    if ($clusters[$i][1] < $clusters[$j][0]) { # gap
                        last;
                    }
                    # first regions are overlapped, check second regions
                    unless ($clusters[$i][2] > $clusters[$j][3] or
                        $clusters[$i][3] < $clusters[$j][2]) { # overlapped
                        $clusters[$i][2] = $clusters[$j][2]
                            if $clusters[$i][2] > $clusters[$j][2];
                        $clusters[$i][3] = $clusters[$j][3]
                            if $clusters[$i][3] < $clusters[$j][3];
                        # update end site for first region
                        $clusters[$i][1] = $clusters[$j][1]
                            if $clusters[$i][1] < $clusters[$j][1];
                        $clusters[$i][4] += $clusters[$j][4];
                        $clusters[$j][4] = 0;
                    }
                }
                push @merged, $clusters[$i];
            }
            if (@merged == @clusters) {
                @clusters = @merged;
                last;
            }
            # sort merged clusters by start sites again
            @clusters = sort {$a->[0] <=> $b->[0]} @merged;
        }
    }
    for (@clusters) {
        my @items = @$_;
        next if $items[-1] < $MinPts;
        $items[0] = 0 if $items[0] < 0;
        $items[1] = $chrSize{$chr1} - 1 if $items[1] > $chrSize{$chr1} - 1;
        $items[2] = 0 if $items[2] < 0;
        $items[3] = $chrSize{$chr2} - 1 if $items[3] > $chrSize{$chr2} - 1;
        print {$to} join("\t", $chr1, @items[0, 1], $chr2, @items[2, 3, 4]), "\n";
    }
}

sub _pcatobedgraph {
    my ($chr, $col, $fto) = @_;
    my ($site, $score, @t, $head);
    my $fin = "$chr.pca";
    open my $in, '<', $fin or die "$fin. $!\n";
    open my $to, '>>', $fto or die "$fto. $!\n";
    $head = <$in>; # PC1 PC2 PC3
    $head = <$in>;
    @t = split /\s+/, $head;
    ($site = $t[0]) =~ s/^X//; # remove starting X added by R
    $score = $t[$col]; # which PC component
    while (<$in>) {
        s/^X//;
        @t = split;
        print {$to} join("\t", $chr, $site, $t[0],
            sprintf("%.3f", $score)), "\n";
        $site = $t[0];
        $score = $t[$col];
    }
    close $in;
    close $to;
}

sub _compartment {
    my ($prefix) = @_;
    my %distance2count;
    my ($in, $to, $head, @t, $i, $num, $bins);
    my $fin = "$prefix.intramatrix";
    open $in, '<', $fin or die "$fin. $!\n";
    $head = <$in>;
    @t = split /\s+/, $head;
    $num = $#t; # number of columns
    while (<$in>) {
        @t = split;
        $i = $. - 1;
        for ($i .. $num) {
            $distance2count{$_ - $i} += $t[$_];
        }
    }
    close $in;
    while (my ($d, $c) = each %distance2count) {
        $bins = $num - $d;
        $distance2count{$d} = $c / $bins; # expected counts
    }
    open $in, '<', $fin or die "$fin. $!\n";
    open $to, '>', "$prefix.oeratio" or die "$prefix.oeratio. $!\n";
    $head = <$in>;
    print {$to} $head;
    while (<$in>) {
        @t = split;
        $i = $. - 1;
        map {if ($t[$_] > 0){ $t[$_] /= $distance2count{abs($_ - $i)}} } 1 .. $num;
        print {$to} join("\t", shift @t, map {sprintf("%.2f", $_)} @t), "\n";
    }
    close $in;
    close $to;
    my $Rcode = <<EOF;
    data <- read.table('$prefix.oeratio', head=T, row.names=1)
    data.cor <- cor(data)           # calculate PCC
    data.cor[is.na(data.cor)] <- 0  # mask NA as 0
    write.table(data.cor, file='$prefix.cor', quote=F, sep="\t")
    data.pca <- prcomp(data.cor)    # do scale is almost the same
    # write done the first three components
    write.table(data.pca\$rotation[, 1:3], file='$prefix.pca', quote=F, sep="\t")
EOF

    my $R = Statistics::R->new();
    $R->run($Rcode);
}

sub _diffCompartments {
    my ($foldchange, $factor, $windowsize, $gapsize) = @_;
    my (%sample1, %sample2, %loci, @t);
    open my $in, '<', $opts{sample1} or die "$!\n";
    while (<$in>) {
        @t = split;
        push @{$loci{$t[0]}}, $t[1];
        push @{$sample1{$t[0]}}, $t[3];
    }
    close $in;

    open $in, '<', $opts{sample2} or die "$!\n";
    while (<$in>) {
        @t = split;
        push @{$sample2{$t[0]}}, $t[3];
    }
    close $in;

    open my $to, '>', $opts{output};
    my $count = 1;
    while (my ($chr, $ref) = each %loci) {
        my @loci = @$ref;
        my @sample1 = @{$sample1{$chr}};
        my @sample2 = @{$sample2{$chr}};
        my $cor = sum(pairwise {$a * $b} @sample1, @sample2);
        if ($cor < 0) {
            warn "The compartments in $chr are inverted! Inverting sample 2 now.\n";
            @sample2 = map {-$_} @sample2;
        }
        my ($cutoff1, $cutoff2);
        unless ($cutoff1) { # use mean value as background
            $cutoff1 = sum(map {abs} @sample1) / scalar(@sample1) / $factor;
        }
        unless ($cutoff2) {
            $cutoff2 = sum(map {abs} @sample2) / scalar(@sample2) / $factor;
        }
        # generate binary list
        my @bins;
        for (0 .. $#sample1-1) {
            if (abs($sample1[$_]) < $cutoff1 and abs($sample2[$_]) < $cutoff2) {
                push @bins, 0;
                next;
            }
            if ($sample1[$_] > 0) { # sample1 positive
                if ($sample2[$_] <= 0) {
                    push @bins, 1;
                }
                else { # sample2 is also positive
                    if ($sample1[$_] / $sample2[$_] >= $foldchange) {
                        push @bins, 1;
                    }
                    elsif ($sample2[$_] / $sample1[$_] >= $foldchange) {
                        push @bins, -1;
                    }
                    else {
                        push @bins, 0;
                    }
                }
            }
            elsif ($sample1[$_] < 0) { # sample1 is negative
                if ($sample2[$_] >= 0) {
                    push @bins, -1;
                }
                else { # sample2 is also negative
                    if ($sample1[$_] / $sample2[$_] >= $foldchange) {
                        push @bins, -1;
                    }
                    elsif ($sample2[$_] / $sample1[$_] >= $foldchange) {
                        push @bins, 1;
                    }
                    else {
                        push @bins, 0;
                    }
                }
            }
            else { # sample1 is zero
                if ($sample2[$_] > 0) {
                    push @bins, -1;
                }
                elsif ($sample2[$_] < 0) {
                    push @bins, 1;
                }
                else { # sample2 is zero
                    push @bins, 0;
                }
            }
        }
        # filer out singletons
        my @backup;
        for ( 2 .. $#bins-2 ) {
            if ($bins[$_] and ($bins[$_] == $bins[$_-1] or $bins[$_] == $bins[$_+1]
                    or $bins[$_] == $bins[$_-2] or $bins[$_] == $bins[$_+2])) {
                push @backup, $bins[$_];
            }
            else {
                push @backup, 0;
            }
        }
        @bins = (0, 0, @backup, 0, 0);
        my ($start1, $end1, $count1, $gap1) = (0, 0, 0, 0); # sample1
        my ($start2, $end2, $count2, $gap2) = (0, 0, 0, 0); # sample2
        my ($sum1, $sum2);
        for (0 .. $#sample1-1) {
            if ($bins[$_] < 0) { # sample2 positive
                if ($_ - $end2 <= $gapsize) { # connected, extend region
                    $end2 = $_;
                    $count2 += $gap2 + 1; # gap may be contained
                }
                else { # not connected
                    if ($count2 >= $windowsize) { # effective region, output
                        $sum1 = scalar(grep {$_ == -1} @bins[$start2 .. $end2]);
                        $sum2 = scalar(grep { $_ != -1} @bins[$start2 .. $end2]);
                        if ($sum1 > $sum2 * 2) { # 2/3 are sample2 positive points
                            print {$to} join("\t", $chr, $loci[$start2], $loci[$end2 + 1], "S2_$count", $count++, '.'), "\n";
                        }
                    }
                    $start2 = $_;
                    $end2 = $_;
                    $count2 = 1;
                }
                $gap2 = 0;
                $gap1++; # a gap for sample1
            }
            elsif ($bins[$_] > 0) { # sample1 positive
                if ($_ - $end1 <= $gapsize) { # connected, extend region
                    $end1 = $_;
                    $count1 += $gap1 + 1; # gap may be contained
                }
                else { # not connected
                    if ($count1 >= $windowsize) { # effective region, output
                        $sum1 = scalar(grep {$_ == 1} @bins[$start1 .. $end1]);
                        $sum2 = scalar(grep { $_ != 1} @bins[$start1 .. $end1]);
                        if ($sum1 > $sum2 * 2) { # 2/3 are sample1 positive points
                            print {$to} join("\t", $chr, $loci[$start1], $loci[$end1 + 1], "S1_$count", $count++, '.'), "\n";
                        }
                    }
                    $start1 = $_;
                    $end1 = $_;
                    $count1 = 1;
                }
                $gap1 = 0;
                $gap2++; # a gap for sample2
            }
            else { # zero, a gap for both samples
                $gap1++;
                $gap2++;
            }
        }
    }
    close $to;
}

sub _callDIdomains {
    my ($fDI, $genome, $output) = @_;
    my $hmmDir = "/home/zhijun/tools/domaincall_software/perl_scripts";
    chomp(my $binsize = `head -1 $fDI | perl -lane 'print \$F[2] - \$F[1]' -`);
    my $tmpDir = "tmp.$$";
    mkdir $tmpDir unless -d $tmpDir;
    my @prefix;
    my $pm = Parallel::ForkManager->new( $cpu, $tmpDir );
    $pm->run_on_finish(
        sub {
            my ( $pid, $exit_code, $indent, $exit_signal, $core_dump,
                $data_ref ) = @_;
            die "Failed to call TADs for '$indent'.\n"
              unless $exit_code == 0;
            push @prefix, $$data_ref;
        }
    );
    for my $chr (@chrs) {
        $pm->start($chr) and next;
        # separate each chr into single file
        my $prefix = "$chr.$$";
        my $cmd = "grep -w $chr $fDI > $prefix";
        system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
        # convert DI file for matlab
        $cmd = "cut -f 4 $prefix > $prefix.converted";
        system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
        # copy matlab file here
        my $mFile = "HMM_calls.m";
        $cmd = "cp $hmmDir/../$mFile $mFile.$$";
        system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
        $mFile .= ".$$";
        $cmd = "sed -i 's/DI_FILENAME/$prefix.converted/' $mFile";
        system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
        $cmd = "sed -i 's/OUTPUT_FILENAME/$prefix.hmm.txt/' $mFile";
        system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
        # call HMM states
        $cmd = "matlab -nodisplay < $mFile";
        system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
        unlink $mFile;
        $cmd = "$hmmDir/file_ends_cleaner.pl $prefix.hmm.txt $prefix | "
            . "$hmmDir/converter_9col.pl > $prefix.hmm.9col";
        system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
        $cmd = "$hmmDir/hmm_probablity_correcter.pl $prefix.hmm.9col 2 0.99 $binsize"
            . " | $hmmDir/hmm-state_caller.pl $ENV{BOWTIE_INDEXES}/$chromSizesFile $chr"
            . " | $hmmDir/hmm-state_domains.pl > $prefix.TADs";
        system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
        $pm->finish(0, \$prefix);
    }
    $pm->wait_all_childs;
    rmdir $tmpDir or warn "Can't delete folder $tmpDir. $!\n";
    for my $prefix (@prefix) {
        my $cmd = "perl -lane 'print unless \@F < 3' $prefix.TADs >> $output";
        system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
        $cmd = "cat $prefix.hmm.9col >> $output.hmm.9col";
        system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
        $cmd = "rm $prefix*";
        system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
    }
    print "\nDone\n";
}

sub _insulationMatrix {
    my ($genome, $output) = @_;
    mkdir $output unless -d $output;
    for my $chr (@chrs) {
        open my $in, '<', "$chr.intramatrix" or die "Can't open file $chr.intramatrix";
        open my $to, '>', "$output/$chr.insulationMatrix";
        my $head = <$in>;
        my @t = split /\s+/, $head;
        shift @t; # position
        my @head;
        for (0 .. $#t-1) {
            push @head,  "$_|$genome|$chr:" . ($t[$_]+1) . "-" . $t[$_+1];
        }
        push @head, "$#t|$genome|$chr:" . ($t[$#t]+1) . "-$chrs{$chr}";
        print {$to} join("\t", '', @head), "\n";
        while (<$in>) {
            @t = split;
            shift @t;
            @t = map {$_ or 'nan'} @t; # replace 0 as nan
            $head = shift @head;
            print {$to} join("\t", $head, @t), "\n";
        }
        close $in;
        close $to;
        system("gzip -f $output/$chr.insulationMatrix");
    }
}

sub _checkABcompartments {
    my ($fcompartment, $genome) = @_;
    open my $in, '<', $fcompartment or die "Can't open file $fcompartment. $!\n";
    my $line = <$in>;
    my @t = split /\s+/, $line;
    my $binsize = $t[2] - $t[1];
    my %regions;
    my ($s, $i);
    $s = $t[3] > 0 ? 1 : $t[3] < 0 ? -1 : 0;
    $i = int($t[1] / $binsize);
    $regions{$t[0]}[$i] = $s;
    while (<$in>) {
        @t = split;
        $s = $t[3] > 0 ? 1 : $t[3] < 0 ? -1 : 0;
        $i = int($t[1] / $binsize);
        $regions{$t[0]}[$i] = $s;
    }
    close $in;
    open $in, '<', "$ENV{$genome}/$genome.knownGene.bed"
        or die "Can't open file $ENV{$genome}/$genome.knownGene.bed. $!\n";
    my %count;
    my $chr = '';
    while (<$in>) {
        @t = split;
        if ($t[0] ne $chr) { # new chr
            $chr = $t[0];
            if (not exists $regions{$chr}) { # ignore this chr
                while (<$in>) {
                    @t = split;
                    last if $t[0] ne $chr;
                }
                last unless $_;
                redo; # recheck this new chr
            }
            # add one more index to $regions{$chr}
            $regions{$chr}[$#{$regions{$chr}}+1] = 0;
        }
        $i = $t[5] eq '+' ? int($t[1] / $binsize) : int($t[2] / $binsize);
        $count{$chr}{$regions{$chr}[$i]}++;
    }
    close $in;
    my %sign;
    while (my ($chr, $ref) = each %count) {
        $sign{$chr} = $ref->{1} > $ref->{-1} ? 1 : -1;
    }
    open $in, '<', $fcompartment;
    open my $to, '>', "tmp.$$";
    while (<$in>) {
        @t = split;
        $t[3] = $t[3] == 0 ? 0 : $t[3] * $sign{$t[0]};
        print {$to} join("\t",  @t), "\n";
    }
    close $in;
    close $to;
    rename "tmp.$$", $fcompartment;
}

sub _annotateInteractions {
    if ($opts{single}) {
        _annotateSingleInteractions(
            @opts{qw(intra inter gene output upstream downstream ratio length)} );
    }
    else {
        _annotateMergedInteractions(
            @opts{qw(intra inter gene output upstream downstream ratio length)} );
    }
}

sub _annotateMergedInteractions {
    # parameters:
    # intra cluster file, BED12 format, can be undef
    # inter cluster file, TXT format, can be undef
    # gene annotation file in BED13 format
    # output file
    # upstream, TSS upstream region to define promoter
    # downstream, TSS downstream region to define promoter
    # ratio, minimal overlap ratio to define a region is promoter
    # length, minimal overlap length to define a region is promoter
    my ( $intra_clu, $inter_clu, $gene_file, $output,
        $upstream, $downstream, $ratio, $length ) = @_;
    my ( %regions, %genes );
    my %interactions;    # interactions annotate result
    my ($total, @t, @sites) = (0);
    if ($intra_clu and -e $intra_clu) {# BED12 format for intra
        my $in_file_name = $intra_clu;    # input file name
        open my $in, '<', $in_file_name
          or die "$0 : failed to open  input file '$in_file_name' : $!\n";
        while (<$in>) {
            @t = split;
            @sites = split /-|;/, $t[3];
            $interactions{$.}{tags} = $sites[-1];
            $interactions{$.}{1} = [$t[0], @sites[ 0, 1 ]];
            $interactions{$.}{2} = [$t[0], @sites[ 2, 3 ]];
            push @{ $regions{ $t[0] } },
              [ @sites[ 0, 1 ], $., 1 ], [ @sites[ 2, 3 ], $., 2 ];
        }
        $total = $.;
        close $in;
    }
    if ($inter_clu and -e $inter_clu) {# TXT format for inter
        my $in_file_name = $inter_clu;    # input file name
        open my $in, '<', $in_file_name
          or die "$0 : failed to open  input file '$in_file_name' : $!\n";
        while (<$in>) {
            @t = split;
            push @{ $regions{ $t[0] } }, [ @t[ 1, 2 ], $. + $total, 1 ];
            push @{ $regions{ $t[3] } }, [ @t[ 4, 5 ], $. + $total, 2 ];
            $interactions{$. + $total}{tags} = $t[6];
            $interactions{$. + $total}{1} = [@t[ 0, 1, 2 ]];
            $interactions{$. + $total}{2} = [@t[ 3, 4, 5 ]];
        }
        close $in;
    }
    unless (%interactions) { # no interaction
        _logging( "No interaction need to annotate. Please check interaction file!");
        exit;
    }
    # merge interacted regions
    my %mergedRegions;
    while (my ($chr, $ref) = each %regions) {
        my $count = 0;
        my ($intra, $inter) = (0, 0); # intra, inter clusters
        my @regions = sort {$a->[0] <=> $b->[0]} @$ref;
        $mergedRegions{$chr}{$count}{start} = $regions[0][0];
        my ($end, @r) = ($regions[0][1]);
        for (@regions) {
            @r = @$_; # start, end, clusterID, part
            if ($r[0] > $end) { # new region encounted
                $mergedRegions{$chr}{$count}{end}   = $end;
                $mergedRegions{$chr}{$count}{intra} = $intra;
                $mergedRegions{$chr}{$count}{inter} = $inter;
                $end = $r[1];
                $count++;
                $mergedRegions{$chr}{$count}{start} = $r[0];
                ($intra, $inter) = (0, 0);
            }
            else {
                $end = $r[1] if $r[1] > $end;
            }
            push @{$mergedRegions{$chr}{$count}{regions}}, $_;
            $interactions{$r[2]}{"region$r[3]"} = $count;
            $interactions{$r[2]}{1}[0] eq $interactions{$r[2]}{2}[0] ?
                $intra++ : $inter++;
        }
        # for the last region
        $mergedRegions{$chr}{$count}{end}   = $end;
        $mergedRegions{$chr}{$count}{intra} = $intra;
        $mergedRegions{$chr}{$count}{inter} = $inter;
    }
    undef %regions;
    # gene file should be in BED format
    my $in_file_name = $gene_file;    # input file name
    open my $in, '<', $in_file_name
      or die "$0 : failed to open  input file '$in_file_name' : $!\n";
    # for genes, record: start, end, gene_name, strand
    while (<$in>) {
        chomp;
        @t = split /\t/;
        unless ( $t[0] =~ /chr.*_/ ) {    # ignore complex chr
            if ($t[12]) { # gene name
                push @{ $genes{ $t[0] } }, [ @t[1, 2, 12, 5] ];
            }
            else {
                push @{ $genes{ $t[0] } }, [ @t[1, 2, 3, 5] ];
            }
        }
    }
    close $in
      or warn "$0 : failed to close input file '$in_file_name' : $!\n";
    # annotate merged regions
    while ( my ($chr, $countRef) = each %mergedRegions ) {
        warn "$chr is not found in gene annotation file $gene_file!\n"
            and next unless exists $genes{$chr};
        my @regionCount = sort { $a <=> $b } keys %$countRef;
        # genes: start, end, gene_name, strand
        my @genes = sort { $a->[0] <=> $b->[0] or $a->[1] <=> $b->[1] }
            @{$genes{$chr}};
        my $i = 0;
        my @promoter;
        for my $count (@regionCount) {
            my ($start, $end) = ($countRef->{$count}{start}, $countRef->{$count}{end});
            my $min;
            for my $j ( $i .. $#genes) {
                my @gene = @{$genes[$j]};
                if ($gene[-1] eq '+') {
                    @promoter = ($gene[0] - $upstream, $gene[0] + $downstream);
                    $promoter[1] = $gene[1] if $promoter[1] > $gene[1];
                    if ($gene[1] < $start) { $i = $j + 1; next; } # gene is on left
                    if ($promoter[0] > $end) { last; } # gene is on right side
                    else { $min = $j unless $min; } # overlap
                    # overlap with promoter region or/and gene body
                    unless ($start > $promoter[1]) { # overlap with promoter
                        my @sites = sort { $a <=> $b } $start, $end, @promoter;
                        my $overlap = $sites[2] - $sites[1];
                        my $maxRatio = ($end - $start + 1) > $promoter[1] - $promoter[0]
                            ? $overlap / ( $promoter[1] - $promoter[0] )
                            : $overlap / ( $end - $start + 1 );
                        if ( $overlap >= $length or $maxRatio >= $ratio ) {
                            $mergedRegions{$chr}{$count}{promoter}{$gene[2]} = undef;
                            next; # check next gene
                        }
                    }
                    # not promoter, then must be enhancer except intergenic
                    $mergedRegions{$chr}{$count}{enhancer}{$gene[2]} = undef
                        unless $end < $gene[0];
                }
                else { # -
                    @promoter = ($gene[1] - $downstream, $gene[1] + $upstream);
                    $promoter[0] = $gene[0] if $promoter[0] < $gene[0];
                    if ($promoter[1] < $start) { $i = $j + 1; next; } # gene is on left
                    if ($gene[0] > $end) { last; } # gene is on right side
                    else { $min = $j unless $min; } # overlap
                    # overlap with promoter region or/and gene body
                    unless ($end < $promoter[0]) { # overlap with promoter
                        my @sites = sort { $a <=> $b } $start, $end, @promoter;
                        my $overlap = $sites[2] - $sites[1];
                        my $maxRatio = ($end - $start + 1) > $promoter[1] - $promoter[0]
                            ? $overlap / ( $promoter[1] - $promoter[0] )
                            : $overlap / ( $end - $start + 1 );
                        if ( $overlap >= $length or $maxRatio >= $ratio ) {
                            $mergedRegions{$chr}{$count}{promoter}{$gene[2]} = undef;
                            next; # check next gene
                        }
                    }
                    # not promoter, then must be enhancer except intergenic
                    $mergedRegions{$chr}{$count}{enhancer}{$gene[2]} = undef
                        unless $start > $gene[1];
                }
            }
            if ($min) { $i = $min; }
        }
    }
    # output annotation result in the same order
    my $to_file_name = $output;    # output file name
    open my $to, '>', $to_file_name
      or die "$0 : failed to open  output file '$to_file_name' : $!\n";
    my %count = (    # count the number of each interaction type
        EE => 0,
        PP => 0,
        PE => 0,
    );
    while ( my ($chr, $countRef) = each %mergedRegions ) {
        my @regionCount = sort { $a <=> $b } keys %$countRef;
        for my $count (@regionCount) {
            my %region = %{$countRef->{$count}};
            my $type1 = $region{promoter} ? 'P' : 'E'; # type of this region
            my %types = ( # EE, EP, PP count
                EE => 0,
                EP => 0,
                PE => 0,
                PP => 0,
            );
            my %clusters; # record clusters engaged in this region
            my $output;   # result for output
            for my $r (@{$region{regions}}) { # for each included small interactions
                my @r = @$r; # start, end, clusterID, part
                if (exists $clusters{$r[2]}) { # locate in the same merged region
                    $types{"$type1$type1"}++;
                    next;
                }
                $output .= "\t$chr:$r[0]-$r[1]";
                my ($chr2, $number2, $count2);
                if ($r[3] == 1) {
                    $number2 = 2;
                    $chr2 = $interactions{$r[2]}{2}[0];
                    $count2 = $interactions{$r[2]}{region2};
                }
                else {
                    $number2 = 1;
                    $chr2 = $interactions{$r[2]}{1}[0];
                    $count2 = $interactions{$r[2]}{region1};
                }
                $output .= "\t$chr2:$interactions{$r[2]}{$number2}[1]-$interactions{$r[2]}{$number2}[2]";
                $output .= "\t$interactions{$r[2]}{tags}";
                $output .= "\t$chr2:$mergedRegions{$chr2}{$count2}{start}-$mergedRegions{$chr2}{$count2}{end}";
                $output .= "\tPromoter: ";
                if ($mergedRegions{$chr2}{$count2}{promoter}) {
                    $types{"${type1}P"}++;
                    $output .= join(',', keys %{$mergedRegions{$chr2}{$count2}{promoter}});
                }
                else {
                    $types{"${type1}E"}++;
                }
                $output .= "\tEnhancer: ";
                if ($mergedRegions{$chr2}{$count2}{enhancer}) {
                     $output .= join(',', keys %{$mergedRegions{$chr2}{$count2}{enhancer}});
                }
                $output .= "\n";
            }
            $types{PE} += $types{EP};
            print {$to}
                  "Region: $chr:$region{start}-$region{end}"
                . "\tIntra: $region{intra}\tInter: $region{inter}"
                . "\tEE: $types{EE}\tPE: $types{PE}\tPP: $types{PP}"
                . "\tPromoter: ";
            print {$to} join(',', keys %{$region{promoter}}) if $region{promoter};
            print {$to} "\tEnhancer: ";
            print {$to} join(',', keys %{$region{enhancer}}) if $region{enhancer};
            print {$to} "\n$output\n";
            $count{EE} += $types{EE};
            $count{PE} += $types{PE};
            $count{PP} += $types{PP};
        }
    }
    close $to;
    # all interactions are count twice
    $count{EE} /= 2;
    $count{PE} /= 2;
    $count{PP} /= 2;
    _logging(
        sprintf("Annotate interactions done! Totally\n"
          . "%16d Enhancer-enhancer interactions, and\n"
          . "%16d Enhancer-promoter interactions, and\n"
          . "%16d Promoter-promoter interactions.\n",
          $count{EE}, $count{PE}, $count{PP})
    );
}

sub _annotateSingleInteractions {
    # parameters:
    # intra cluster file, BED12 format, can be undef
    # inter cluster file, TXT format, can be undef
    # gene annotation file in BED13 format
    # output file
    # upstream, TSS upstream region to define promoter
    # downstream, TSS downstream region to define promoter
    # ratio, minimal overlap ratio to define a region is promoter
    # length, minimal overlap length to define a region is promoter
    my ( $intra_clu, $inter_clu, $gene_file, $output,
        $upstream, $downstream, $ratio, $length ) = @_;
    my ( %genes );
    my %interactions;    # interactions annotate result
    my ($total, @t, @sites) = (0);
    my %mergedRegions;
    my $count = 0;
    if ($intra_clu and -e $intra_clu) {# BED12 format for intra
        my $in_file_name = $intra_clu;    # input file name
        open my $in, '<', $in_file_name
          or die "$0 : failed to open  input file '$in_file_name' : $!\n";
        while (<$in>) {
            @t = split;
            @sites = split /-|;/, $t[3];
            $interactions{$.}{tags} = $sites[-1];
            $interactions{$.}{1} = [$t[0], @sites[ 0, 1 ]];
            $interactions{$.}{2} = [$t[0], @sites[ 2, 3 ]];
            @{$mergedRegions{$t[0]}{$count}}{qw(start end intra inter)}
                = (@sites[0, 1], 1, 0);
            push @{$mergedRegions{$t[0]}{$count}{regions}}, [@sites[0, 1], $., 1];
            $interactions{$.}{"region1"} = $count;
            $count++;
            @{$mergedRegions{$t[0]}{$count}}{qw(start end intra inter)}
                = (@sites[2, 3], 1, 0);
            push @{$mergedRegions{$t[0]}{$count}{regions}}, [@sites[2, 3], $., 2];
            $interactions{$.}{"region2"} = $count;
            $count++;
        }
        $total = $.;
        close $in;
    }
    if ($inter_clu and -e $inter_clu) {# TXT format for inter
        my $in_file_name = $inter_clu;    # input file name
        open my $in, '<', $in_file_name
          or die "$0 : failed to open  input file '$in_file_name' : $!\n";
        while (<$in>) {
            @t = split;
            my $id = $. + $total;
            $interactions{$id}{tags} = $t[6];
            $interactions{$id}{1} = [@t[ 0, 1, 2 ]];
            $interactions{$id}{2} = [@t[ 3, 4, 5 ]];
            @{$mergedRegions{$t[0]}{$count}}{qw(start end intra inter)}
                = (@t[1, 2], 0, 1);
            push @{$mergedRegions{$t[0]}{$count}{regions}}, [@t[1, 2], $id, 1];
            $interactions{$id}{"region1"} = $count;
            $count++;
            @{$mergedRegions{$t[3]}{$count}}{qw(start end intra inter)}
                = (@t[4, 5], 0, 1);
            push @{$mergedRegions{$t[3]}{$count}{regions}}, [@t[4, 5], $id, 2];
            $interactions{$id}{"region2"} = $count;
            $count++;
        }
        close $in;
    }
    unless (%interactions) { # no interaction
        die "No interaction need to annotate. Please check interaction file!\n";
    }
    # gene file should be in BED or GTF format
    my $in_file_name = $gene_file;    # input file name
    open my $in, '<', $in_file_name
      or die "$0 : failed to open  input file '$in_file_name' : $!\n";
    # for genes, record: start, end, gene_name, strand
    while(<$in>) {
        chomp;
        @t = split /\t/;
        unless ( $t[0] =~ /chr.*_/ ) {    # ignore complex chr
            if ($t[12]) { # gene name
                push @{ $genes{ $t[0] } }, [ @t[1, 2, 12, 5] ];
            }
            else {
                push @{ $genes{ $t[0] } }, [ @t[1, 2, 3, 5] ];
            }
        }
    }
    close $in
      or warn "$0 : failed to close input file '$in_file_name' : $!\n";
    while ( my ($chr, $countRef) = each %mergedRegions ) {
        warn "$chr is not found in gene annotation file $gene_file!\n"
            and next unless exists $genes{$chr};
        my @regionCount = sort { $countRef->{$a}{start} <=> $countRef->{$b}{start}
            or $countRef->{$a}{end} <=> $countRef->{$b}{end}
            } keys %$countRef;
        # genes: start, end, gene_name, strand
        my @genes = sort { $a->[0] <=> $b->[0] or $a->[1] <=> $b->[1] }
            @{$genes{$chr}};
        my $i = 0;
        my @promoter;
        for my $count (@regionCount) {
            my ($start, $end) = ($countRef->{$count}{start}, $countRef->{$count}{end});
            my $min;
            for my $j ( $i .. $#genes) {
                my @gene = @{$genes[$j]};
                if ($gene[-1] eq '+') {
                    @promoter = ($gene[0] - $upstream, $gene[0] + $downstream);
                    $promoter[1] = $gene[1] if $promoter[1] > $gene[1];
                    if ($gene[1] < $start) { $i = $j + 1; next; } # gene is on left
                    if ($promoter[0] > $end) { last; } # gene is on right side
                    else { $min = $j unless $min; } # overlap
                    # overlap with promoter region or/and gene body
                    unless ($start > $promoter[1]) { # overlap with promoter
                        my @sites = sort { $a <=> $b } $start, $end, @promoter;
                        my $overlap = $sites[2] - $sites[1];
                        my $maxRatio = ($end - $start + 1) > $promoter[1] - $promoter[0]
                            ? $overlap / ( $promoter[1] - $promoter[0] )
                            : $overlap / ( $end - $start + 1 );
                        if ( $overlap >= $length or $maxRatio >= $ratio ) {
                            $mergedRegions{$chr}{$count}{promoter}{$gene[2]} = undef;
                            next; # check next gene
                        }
                    }
                    # not promoter, then must be enhancer except intergenic
                    $mergedRegions{$chr}{$count}{enhancer}{$gene[2]} = undef
                        unless $end < $gene[0];
                }
                else { # -
                    @promoter = ($gene[1] - $downstream, $gene[1] + $upstream);
                    $promoter[0] = $gene[0] if $promoter[0] < $gene[0];
                    if ($promoter[1] < $start) { $i = $j + 1; next; } # gene is on left
                    if ($gene[0] > $end) { last; } # gene is on right side
                    else { $min = $j unless $min; } # overlap
                    # overlap with promoter region or/and gene body
                    unless ($end < $promoter[0]) { # overlap with promoter
                        my @sites = sort { $a <=> $b } $start, $end, @promoter;
                        my $overlap = $sites[2] - $sites[1];
                        my $maxRatio = ($end - $start + 1) > $promoter[1] - $promoter[0]
                            ? $overlap / ( $promoter[1] - $promoter[0] )
                            : $overlap / ( $end - $start + 1 );
                        if ( $overlap >= $length or $maxRatio >= $ratio ) {
                            $mergedRegions{$chr}{$count}{promoter}{$gene[2]} = undef;
                            next; # check next gene
                        }
                    }
                    # not promoter, then must be enhancer except intergenic
                    $mergedRegions{$chr}{$count}{enhancer}{$gene[2]} = undef
                        unless $start > $gene[1];
                }
            }
            if ($min) { $i = $min; }
        }
    }
    # output annotation result in the same order
    my $to_file_name = $output;    # output file name
    open my $to, '>', $to_file_name
      or die "$0 : failed to open  output file '$to_file_name' : $!\n";
    my %count = (    # count the number of each interaction type
        EE => 0,
        PP => 0,
        PE => 0,
        EP => 0,
    );
    while ( my ($chr, $countRef) = each %mergedRegions ) {
        my @regionCount = sort { $countRef->{$a}{start} <=> $countRef->{$b}{start}
            or $countRef->{$a}{end} <=> $countRef->{$b}{end}
            } keys %$countRef;
        for my $count (@regionCount) {
            my %region = %{$countRef->{$count}};
            my $type1 = $region{promoter} ? 'P' : 'E'; # type of this region
            my %clusters; # record clusters engaged in this region
            my $output;   # result for output
            my $type2;
            for my $r (@{$region{regions}}) { # only one region, actually
                my @r = @$r; # start, end, clusterID, part
                next unless exists $interactions{$r[2]};
                $output .= "$chr:$r[0]-$r[1]\tPromoter: ";
                $output .= $region{promoter} ? join(',', keys %{$region{promoter}}) : '';
                $output .= "\tEnhancer: ";
                $output .= $region{enhancer} ? join(',', keys %{$region{enhancer}}) : '';
                my ($chr2, $number2, $count2);
                if ($r[3] == 1) {
                    $number2 = 2;
                    $chr2 = $interactions{$r[2]}{2}[0];
                    $count2 = $interactions{$r[2]}{region2};
                }
                else {
                    $number2 = 1;
                    $chr2 = $interactions{$r[2]}{1}[0];
                    $count2 = $interactions{$r[2]}{region1};
                }
                $output .= "\t$chr2:$interactions{$r[2]}{$number2}[1]-$interactions{$r[2]}{$number2}[2]";
                $output .= "\tPromoter: ";
                if ($mergedRegions{$chr2}{$count2}{promoter}) {
                    $type2 = 'P';
                    $output .= join(',', keys %{$mergedRegions{$chr2}{$count2}{promoter}});
                }
                else {
                    $type2 = 'E';
                }
                $output .= "\tEnhancer: ";
                if ($mergedRegions{$chr2}{$count2}{enhancer}) {
                     $output .= join(',', keys %{$mergedRegions{$chr2}{$count2}{enhancer}});
                }
                $output .= "\t$type1$type2\t$interactions{$r[2]}{tags}\n";
                delete $interactions{$r[2]};
                print {$to} "$output";
                $count{"$type1$type2"}++;
            }
        }
    }
    close $to;
    # all interactions are count twice
    $count{PE} += $count{EP};
    _logging(
        sprintf("Annotate interactions done! Totally\n"
          . "%16d Enhancer-enhancer interactions, and\n"
          . "%16d Enhancer-promoter interactions, and\n"
          . "%16d Promoter-promoter interactions.\n",
          $count{EE}, $count{PE}, $count{PP})
    );
}

sub _parseAnnotate {
    my ($fannotate, $output) = @_;
    open my $in, '<', $fannotate or die "$fannotate. $!\n";
    open my $to, '>', $output or die "$output. $!\n";
    my (@t, $p, $pgs, $e, $egs, $c1, $s1, $c2, $s2, $p2, $e2, $pgs2, $egs2, $type);
    while (<$in>) { # Region: line
        @t = split;
        ($p, $pgs, $e, $egs) = ();
        if ($t[13] eq 'Enhancer:') {
            $p = 0;
            $pgs = '';
        }
        else {
            $p = 1;
            $pgs = $t[13];
        }
        if ($t[-1] eq "Enhancer:") {
            $egs = '';
        }
        else {
            $egs = $t[-1];
        }
        $e = 1 unless $p;
        while (<$in>) {
            last if /^$/;
            @t = split;
            $t[0] =~ /^(\w+):(\d+)-/;
            ($c1, $s1) = ($1, $2);
            $t[1] =~ /^(\w+):(\d+)-/;
            ($c2, $s2) = ($1, $2);
            next unless $c1 le $c2 and $s1 < $s2;
            ($p2, $pgs2, $e2, $egs2) = ();
            if ($t[5] eq 'Enhancer:') {
                $p2 = 0;
                $pgs2 = '';
            }
            else {
                $p2 = 1;
                $pgs2 = $t[5];
            }
            if ($t[-1] eq "Enhancer:") {
                $egs2 = '';
            }
            else {
                $egs2 = $t[-1];
            }
            $e2 = 1 unless $p2;
            if ($p and $p2) {
                $type = 'PP';
            }
            elsif ($p) {
                $type = 'PE';
            }
            elsif ($p2) {
                $type = 'EP';
            }
            else {
                $type = 'EE';
            }
            print {$to} join("\t", $t[0], "Promoter: $pgs", "Enhancer: $egs",
                $t[1], "Promoter: $pgs2", "Enhancer: $egs2", $type, $t[2]
            ), "\n";
        }
    }
    close $in;
    close $to;
}

sub _getInteractedGenes {
    my ($input, $output, $single) = @_;
    my %genes;
    open my $in, '<', $input  or die "Can't open input $input. $!\n";
    if (not $single) {
        while (<$in>) {
            chomp;
            next if /^$/; # empty
            my @t = split /\t/;
            if (/^Region/) {
                my @s = split /\s+/, $t[6]; # promoter
                if ($s[1]) {
                    my @genes = split /,/, $s[1];
                    $genes{$_} = 'promoter' for @genes;
                }
                @s = split /\s+/, $t[7]; # enhancer
                if ($s[1]) {
                    my @genes = split /,/, $s[1];
                    for (@genes) {
                        $genes{$_} = 'enhancer' unless $genes{$_};
                    }
                }
            }
            else {
                my @s = split /\s+/, $t[4]; # promoter
                if ($s[1]) {
                    my @genes = split /,/, $s[1];
                    $genes{$_} = 'promoter' for @genes;
                }
                @s = split /\s+/, $t[5]; # enhancer
                if ($s[1]) {
                    my @genes = split /,/, $s[1];
                    for (@genes) {
                        $genes{$_} = 'enhancer' unless $genes{$_};
                    }
                }
            }
        }
    }
    else {
        while (<$in>) {
            chomp;
            next if /^$/; # empty
            my @t = split /\t/;
            my (@p, @e);
            my @s = split /\s+/, $t[1]; # promoter
            if ($s[1]) {
                push @p, split /,/, $s[1];
            }
            @s = split /\s+/, $t[4]; # promoter
            if ($s[1]) {
                push @p, split /,/, $s[1];
            }
            $genes{$_} = 'promoter' for @p;
            @s = split /\s+/, $t[2]; # enhancer
            if ($s[1]) {
                push @e, split /,/, $s[1];
            }
            @s = split /\s+/, $t[5]; # enhancer
            if ($s[1]) {
                push @e, split /,/, $s[1];
            }
            for (@e) {
                $genes{$_} = 'enhancer' unless $genes{$_};
            }
        }
    }
    close $in;
    open my $to, '>', $output or die "Can't create output $output. $!\n";
    for my $g (sort {$genes{$b} cmp $genes{$a}} keys %genes) {
        print {$to} "$g\t$genes{$g}\n";
    }
    close $to;
}

sub _selectInteractions {
    # parameters:
    # genes:        gene list file, first column is gene name
    # annotate:     interactions annotation file
    # type:         'intra', 'inter', or 'all' interactions
    # merge:        merge all genes output to output or output them separately
    # output:       output file name or prefix for multiple files
    my ( $fgenes, $fannotate, $type, $merge, $foutput ) = @_;
    my %interactions;
    if (-e $fgenes) { # a file is given
        my      $in_file_name = $fgenes;                # input file name
        open  my $in, '<', $in_file_name
            or die  "$0 : failed to open  input file '$in_file_name' : $!\n";
        while (<$in>) {
            chomp;
            my $gene = (split /\t/)[0];
            $interactions{$gene} = undef;
        }
        close  $in
            or warn "$0 : failed to close input file '$in_file_name' : $!\n";
    }
    else { # a gene list is given
        $interactions{$_} = undef for split /,/, $fgenes;
    }
    my %position;    # position for each gene
    open my $in, $fannotate or die "Can't open $fannotate. $!\n";
    my (@t, @promoter, @enhancer, @genes, @s);
    my $head = <$in>;
    seek $in, 0, 0;
    if ($head =~ /^Region/) { # merged regions annotated
        while (<$in>) {
            chomp;
            if (/^Region/) {
                @t = split /\t/;
                @promoter = split /\s+/, $t[6]; # Promoter
                @enhancer = split /\s+/, $t[7]; # Enhancer
                @genes = $promoter[1] ? split /,/, $promoter[1] : ();
                push @genes, split /,/, $enhancer[1] if $enhancer[1];
                my %genes;
                for my $g (@genes) {
                    $genes{$g} = undef if exists $interactions{$g};
                }
                if (%genes) {
                    @genes = keys %genes;
                    if ($promoter[1]) { # update position information for genes
                        my @p = split /[-: ]+/, $t[0];
                        for my $g (@genes) {
                            if (exists $position{$g}) {
                                if ($p[1] eq $position{$g}[0]) {
                                    $position{$g}[2] = $p[3]; # Regions are sorted
                                }
                            }
                            else {
                                $position{$g} = [@p[1, 2, 3]];
                            }
                        }
                    }
                    if ($type eq 'all') { # both intra and inter
                        while (<$in>) {
                            last if /^$/; # empty line
                            chomp;
                            @s = split /\s+/;
                            @t = split /[-:]/, $s[1];
                            push @t, split /[-:]/, $s[2];
                            push @t, $s[3];
                            if ($t[0] eq $t[3]) { # intra
                                if ($t[1] > $t[4]) {
                                    @t[0 .. 5] = @t[3, 4, 5, 0, 1, 2];
                                }
                            }
                            $interactions{$_}{join(' ', @t[0 .. 6])} = undef for @genes;
                        }
                    }
                    elsif ($type eq 'intra') {
                        while (<$in>) {
                            last if /^$/; # empty line
                            chomp;
                            @s = split /\s+/;
                            @t = split /[-:]/, $s[1];
                            push @t, split /[-:]/, $s[2];
                            push @t, $s[3];
                            if ($t[0] eq $t[3]) { # intra
                                if ($t[1] > $t[4]) {
                                    @t[0 .. 5] = @t[3, 4, 5, 0, 1, 2];
                                }
                                $interactions{$_}{join(' ', @t[0 .. 6])} = undef for @genes;
                            }
                        }
                    }
                    else { # inter
                        while (<$in>) {
                            last if /^$/; # empty line
                            chomp;
                            @s = split /\s+/;
                            @t = split /[-:]/, $s[1];
                            push @t, split /[-:]/, $s[2];
                            push @t, $s[3];
                            if ($t[0] ne $t[3]) { # inter
                                $interactions{$_}{join(' ', @t[0 .. 6])} = undef for @genes;
                            }
                        }
                    }
                }
            }
        }
    }
    else { # single interaction annotated
        while (<$in>) {
            chomp;
            @t = split /\t/;
            my ($chr1, $start1, $end1) = split /[-:]/, $t[0];
            my ($chr2, $start2, $end2) = split /[-:]/, $t[3];
            next if $chr1 eq $chr2 and $type eq 'inter';
            next if $chr1 ne $chr2 and $type eq 'intra';
            @promoter = split /\s+/, $t[1]; # Promoter
            @enhancer = split /\s+/, $t[2]; # Enhancer
            @genes = $promoter[1] ? split /,/, $promoter[1] : ();
            push @genes, split /,/, $enhancer[1] if $enhancer[1];
            @promoter = split /\s+/, $t[4]; # Promoter
            @enhancer = split /\s+/, $t[5]; # Enhancer
            push @genes, split /,/, $promoter[1] if $promoter[1];
            push @genes, split /,/, $enhancer[1] if $enhancer[1];
            my %genes;
            for my $g (@genes) {
                $genes{$g} = undef if exists $interactions{$g};
            }
            if (%genes) {
                @genes = keys %genes;
                $interactions{$_}{join(' ', $chr1, $start1, $end1,
                    $chr2, $start2, $end2, $t[7])} = undef for @genes;
                for my $g (@genes) { # set position for gene
                    if (exists $position{$g}) {
                        if ($chr1 eq $position{$g}[0]) {
                            $position{$g}[2] = $end1; # Regions are sorted
                        }
                    }
                    else {
                        $position{$g} = [$chr1, $start1, $end1];
                    }
                    if ($chr2 eq $position{$g}[0]) {
                        $position{$g}[2] = $end2; # Regions are sorted
                    }
                }
            }
        }
    }
    close $in;
    if ($merge) { # merge all output
        open my $to, '>', $foutput or die "Can't create file $foutput. $!\n";
        @genes = keys %position;
        my %output; # record and then sort them before output
        while (my ($gene, $ref) = each %interactions) {
            while (my ($k, $v) = each %$ref) {
                my @t = split /\s+/, $k;
                if ($t[0] eq $t[3]) { # intra, output in BED12
                    my $record = join("\t",
                        $t[0], $t[1], $t[5],
                        "$t[1]-$t[2];$t[4]-$t[5];$t[6]",
                        500, "+", $t[1], $t[5], "255,0,0\t2",
                        ( $t[2] - $t[1] ) . ',' . ( $t[5] - $t[4] ),
                        '0,' . ( $t[4] - $t[1] )
                    );
                    $output{$record}{chr} = $t[0];
                    $output{$record}{start} = $t[1];
                }
                else { # inter, output in BED6
                    my $record = join( "\t",
                        $t[0], $t[1], $t[2],
                        "$t[0]:$t[1]-$t[2];$t[3]:$t[4]-$t[5];$t[6]",
                        500, "+"
                    );
                    $output{$record}{chr} = $t[0];
                    $output{$record}{start} = $t[1];
                    $record = join( "\t",
                        $t[3], $t[4], $t[5],
                        "$t[0]:$t[1]-$t[2];$t[3]:$t[4]-$t[5];$t[6]",
                        500, "+"
                    );
                    $output{$record}{chr} = $t[3];
                    $output{$record}{start} = $t[4];
                }
            }
        }
        print {$to} "$_\n"
            for sort {
                 $output{$a}{chr} cmp $output{$b}{chr}
              or $output{$a}{start} <=> $output{$b}{start}
            } keys %output;
        close $to;
    }
    else { # output one file for each gene
        while (my ($gene, $ref) = each %interactions) {
            open my $to, '>', "$foutput.$gene.bed"
                or die "Can't create file $foutput.$gene.bed! $!\n";
            print {$to} "browser position $position{$gene}\n";
            print {$to} "browser position $position{$gene}[0]:"
              . "$position{$gene}[1]-$position{$gene}[2]\n";
            print {$to} "track name='$gene related interactions' "
              . "description='$gene related interactions' "
              . "visibility=pack color=255,0,0\n";
            my %output; # record and then sort them before output
            while (my ($k, $v) = each %$ref) {
                my @t = split /\s+/, $k;
                if ($t[0] eq $t[3]) { # intra, output in BED12
                    my $record = join("\t",
                        $t[0], $t[1], $t[5],
                        "$t[1]-$t[2];$t[4]-$t[5];$t[6]",
                        500, "+", $t[1], $t[5], "255,0,0\t2",
                        ( $t[2] - $t[1] ) . ',' . ( $t[5] - $t[4] ),
                        '0,' . ( $t[4] - $t[1] )
                    );
                    $output{$record}{chr} = $t[0];
                    $output{$record}{start} = $t[1];
                }
                else { # inter, output in BED6
                    my $record = join( "\t",
                        $t[0], $t[1], $t[2],
                        "$t[0]:$t[1]-$t[2];$t[3]:$t[4]-$t[5];$t[6]",
                        500, "+"
                    );
                    $output{$record}{chr} = $t[0];
                    $output{$record}{start} = $t[1];
                    $record = join( "\t",
                        $t[3], $t[4], $t[5],
                        "$t[0]:$t[1]-$t[2];$t[3]:$t[4]-$t[5];$t[6]",
                        500, "+"
                    );
                    $output{$record}{chr} = $t[3];
                    $output{$record}{start} = $t[4];
                }
            }
            print {$to} "$_\n"
                for sort {
                     $output{$a}{chr} cmp $output{$b}{chr}
                  or $output{$a}{start} <=> $output{$b}{start}
                } keys %output;
            close $to;
        }
    }
}

sub _interactionsToWashU {
    my ($input, $output) = @_;
    open my $in, '<', $input or die "Can't open file $input. $!\n";
    open my $to, '>', $output or die "Can't create file $output. $!\n";
    my $count = 0;
    while (<$in>) {
        my @t = split;
        my $chr = $t[0];
        @t = split /-|;/, $t[3];
        print {$to} join("\t", $chr, @t[0, 1], "$chr:$t[2]-$t[3],$t[4]",
            $count++, '.'), "\n";
        print {$to} join("\t", $chr, @t[2, 3], "$chr:$t[0]-$t[1],$t[4]",
            $count++, '.'), "\n";
    }
    close $in;
    close $to;
    _bgzipFile($output);
}

sub _intraToBed {                         # intra to BED12
    my ( $in_file_name, $to_file_name ) = @_;
    my %clusters;
    open my $in, '<', $in_file_name
      or die "$0 : failed to open  input file '$in_file_name' : $!\n";
    open my $to, '>', $to_file_name
      or die "$0 : failed to open  output file '$to_file_name' : $!\n";
    while (<$in>) {
        my @t = split;
        print {$to} join( "\t",
            $t[0], $t[1], $t[5],
            "$t[1]-$t[2];$t[4]-$t[5];$t[6]",
            $t[7] || 0, "+", $t[1], $t[5], "255,0,0\t2",
            ( $t[2] - $t[1] ) . ',' . ( $t[5] - $t[4] ),
            '0,' . ( $t[4] - $t[1] ) ),
          "\n";
    }
    close $in
      or warn "$0 : failed to close input file '$in_file_name' : $!\n";
    close $to
      or warn "$0 : failed to close output file '$to_file_name' : $!\n";
}

sub _calcInsulationScores {
    my ($bedGraph, $bins) = @_;
    my $pm = Parallel::ForkManager->new( $cpu );
    $pm->run_on_finish(
        sub {
            my ( $pid, $exit_code, $indent ) = @_;
            die "Failed to process call TADs for '$indent'.\n"
              unless $exit_code == 0;
        }
    );
    my $id = $$;
    for my $chr (@chrs) {
        $pm->start($chr) and next;
        my $bedGraph = "$chr.insulationScore.bedGraph.$id";
        _calcInsulationScore($chr, $bedGraph, $bins);
        $pm->finish();
    }
    $pm->wait_all_childs;
    my $cmd = "cat *insulationScore.bedGraph.$id > $bedGraph";
    system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
    $cmd = "rm *insulationScore.*$id";
    system($cmd) == 0 or die "CMD: $cmd failed. $!\n";
    if ($opts{bgzip}) {
        system("bgzip -f $bedGraph");
        system("tabix -fp bed $bedGraph.gz");
    }
}

sub _calcInsulationScore {
    my ($chr, $output, $bins) = @_;
    my @scores;
    my (@head, $length);
    my $input = "$chr.intramatrix";
    open my $in, '<', $input or die "Can't open file $input. $!\n";
    my $head = <$in>;
    @head = split /\s+/, $head;
    # initial the first scoring window
    my ($sumA, $sumB) = (0, 0);
    my (@sumA1, @sumA2, @sumB1, @sumB2, @sumB3);
    my (@t, $index);
    my $skipBins = 3;
    while (<$in>) {
        @t = split;
        $index = $. - 1;
        push @sumA1, sum(@t[$index .. $index+$bins-1]);
        push @sumB1, sum(@t[$index+$bins .. $index+2*$bins-1]);
        if ($index <= $bins) {
            $sumA += $_ for @t[1 .. $index];
        }
        else {
            push @sumA2, sum(@t[$index-$bins+1 .. $index]);
            push @sumB2, sum(@t[$index-$bins .. $index-1]);
            push @sumB3, sum(@t[$index+1 .. $index+$bins]);
            $sumA += $_ for @t[$bins+1 .. $index];
            $sumB += $_ for @t[1 .. $bins];
        }
        last if ($index == 2 * $bins);
    }
    my (@sumAs, @sumBs);
    push @scores, 0 for 1 .. $bins;
    push @sumAs, $sumA;
    push @sumBs, $sumB;
    $length = $#head;
    while (<$in>) {
        @t = split;
        $index = $. - 1;
        $t[$_] = 0 for $index-$skipBins .. $index+$skipBins; # mask as zeros
        push @sumA1, sum(@t[$index .. $index+$bins-1]);
        push @sumA2, sum(@t[$index-$bins+1 .. $index]);
        push @sumB1, sum(@t[$index+$bins .. $index+2*$bins-1]);
        push @sumB2, sum(@t[$index-$bins .. $index-1]);
        push @sumB3, sum(@t[$index+1 .. $index+$bins]);
        $sumA += $sumA2[0] + $sumA2[-1] - $sumA1[0] - $sumA1[$bins];
        shift @sumA1;
        shift @sumA2;
        $sumB += sum(@t[$index-2*$bins+1 .. $index-$bins]) + $sumB3[0] - $sumB1[0] - $sumB2[0];
        shift @sumB1;
        shift @sumB2;
        shift @sumB3;
        push @sumAs, $sumA;
        push @sumBs, $sumB;
        last if $index + 2 * $bins - 1 == $length;
    }
    close $in;
    my $meanA = sum(@sumAs) / @sumAs;
    @sumAs = map {$_ + $meanA} @sumAs;
    push @scores, pairwise {$b / $a} @sumAs, @sumBs;
    push @scores, 0 for $#scores .. $#head;
    @scores = map {sprintf("%.3f", $_)} @scores;
    open my $to, '>', $output or die "Can't create file $output. $!\n";
    for (1 .. $length-1) {
        print {$to} join("\t", $chr, $head[$_], $head[$_+1], $scores[$_]), "\n";
    }
    close $to;
}

sub _callInsulationTADs {
    my ( $bedGraph, $window, $boundarySize, $output ) = @_;
    my ( $in, %scores, @s );
    if ($bedGraph =~ /\.gz$/i) {
        open $in, "gzip -cd $bedGraph |" or die "Can't open file $bedGraph. $!\n";
        $bedGraph =~ s/.gz$//i;
    }
    else {
        open $in, '<', $bedGraph or die "Can't open file $bedGraph. $!\n";
    }
    while (<$in>) {
        @s = split;
        push @{ $scores{ $s[0] } }, $s[3];
    }
    close $in;
    my $binsize          = $s[2] - $s[1];
    my $smoothedBedGraph = $bedGraph;
    $smoothedBedGraph =~ s/(\w+)$/W$window.smoothed.$1/;
    open my $to, '>', $smoothedBedGraph;
    my (@depth, %sites, %smoothedScores, %peaks, @boundary);
    while ( my ( $chr, $ref ) = each %scores ) {
        my @smoothedScores = map { sprintf("%.3f", $_) }
            _smoothVector( $ref, $window, 0.99 );
        $smoothedScores{$chr} = [@smoothedScores];
        for ( 0 .. $#smoothedScores - 1 ) {
            print {$to} join( "\t",
                $chr,
                $_ * $binsize,
                ( $_ + 1 ) * $binsize,
                $smoothedScores[$_] ),
              "\n";
        }
        my @peaks   = _searchPeaks(@smoothedScores);
        my @valleys = _searchValleys(@smoothedScores);
        my @sites = sort { $a <=> $b } @peaks, @valleys;
        $sites{$chr} = [@sites];
        my $min;
        # for each valley, record its lowest height compared to peaks
        for ( my $i = 1 ; $i < $#sites ; $i += 2 ) { # all valleys
            $min = $smoothedScores[ $sites[ $i - 1 ] ] <
                $smoothedScores[ $sites[ $i + 1 ] ]
                ? $smoothedScores[ $sites[ $i - 1 ] ]
                : $smoothedScores[ $sites[ $i + 1 ] ];
            push @depth, $min - $smoothedScores[ $sites[$i] ];
        }
    }
    close $to;
    # scores below the mean of @depth are candidate weak TADs need to be
    # removed, then estimate cutoff from these candidates
    my $mean = sum(@depth) / scalar(@depth);
    my @low = grep {$_ < $mean} @depth;
    $mean = sum(@low) / scalar(@low);
    my $sd = sqrt(sum(map {($mean - $_) ** 2} @low) / scalar(@low));
    my $cutoff = $mean;# - $sd;
#    print "$mean, $sd, $cutoff\n";
    while ( my ( $chr, $ref ) = each %sites ) {
        my @sites = @$ref;
        my @smoothedScores = @{$smoothedScores{$chr}};
        my @flagged = map {[$_, 1]} @sites; # 1 for peaks
        # mask each pair peak and valley below the cutoff
        for ( my $i = 1 ; $i < $#sites ; $i += 2 ) { # all valleys
            $flagged[$i][1] = 2; # 2 for valleys
            if ($smoothedScores[$sites[$i-1]] - $smoothedScores[$sites[$i]] < $cutoff) {
                $flagged[$i-1][1] = 0;
                $flagged[$i][1] = 0;
            }
            if ($smoothedScores[$sites[$i+1]] - $smoothedScores[$sites[$i]] < $cutoff) {
                $flagged[$i+1][1] = 0;
                $flagged[$i][1] = 0;
            }
        }
        my (@kept, $score, $site, @tmp, @tmp1, $min);
        # remove masked peaks and valleys, but keep a peak is followed by a
        # valley
        for (@flagged) {
            if ($_->[1]) { # not masked
                if (scalar(@tmp) > 2) { # multiple masked points
                    while (@tmp > 1) { # iteratively removed masked points
                        $min = abs($smoothedScores[$tmp[1]] - $smoothedScores[$tmp[0]]);
                        for (2 .. $#tmp) {
                            $min = abs($smoothedScores[$tmp[$_]] - $smoothedScores[$tmp[$_-1]])
                                if $min > abs($smoothedScores[$tmp[$_]] - $smoothedScores[$tmp[$_-1]]);
                        }
                        last if $min > $cutoff;
                        @tmp1 = (shift @tmp);
                        while (@tmp) {
                            if (abs($smoothedScores[$tmp[0]] - $smoothedScores[$tmp1[-1]]) == $min) {
                                pop @tmp1;
                                shift @tmp;
                                last;
                            }
                            else {
                                push @tmp1, shift @tmp;
                            }
                        }
                        @tmp = (@tmp1, @tmp);
                    }
                    push @kept, @tmp;
                }
                @tmp = ();
                push @kept, $_->[0]; # only keep positions
            }
            else { # masked site
                push @tmp, $_->[0]; # masked sites
            }
        }
        my @peaks;
        for ( my $i = 0 ; $i <= $#kept ; $i += 2 ) { # all peaks
            push @peaks, $kept[$i];
        }
        $peaks{$chr} = [@peaks];
#        for (@valleys) {
#            push @boundary, @smoothedScores[$_-$boundarySize .. $_+$boundarySize];
#        }
    }
    # estimate boundary cutoff from the @boundary
#    $mean = sum(@boundary) / scalar(@boundary);
#    @low = grep {$_ < $mean} @boundary;
#    $mean = sum(@low) / scalar(@low);
#    $sd = sqrt(sum(map {($mean - $_) ** 2} @low) / scalar(@low));
    $cutoff = 0.1;
#    $cutoff = $mean - $sd;
#    print "$mean, $sd, $cutoff\n";
    open $to, '>', $output;
    while ( my ( $chr, $ref ) = each %peaks ) {
        my @peaks = @$ref;
        my @smoothedScores = @{$scores{$chr}};
        my @valleys = _searchExactValleys(\@smoothedScores, \@peaks);
        my $p = 0;
        $p++ until $smoothedScores[$p] >= $cutoff;
        my $count = 1;
        my ($l, $r);
        for ( @valleys ) {
            $l = $r = $_;
            while ($smoothedScores[$l] < $cutoff) { $l--; }
            print {$to} join( "\t",
                $chr,
                $binsize * $p,
                $binsize * ($l + 1),
                $binsize * $p . "-" . $binsize * ($l + 1),
                $count,
                '.' ),
              "\n";
            $count++;
            while ($smoothedScores[$r] < $cutoff) { $r++; }
            if ($l == $r) {
                $p = $r + 1;
            }
            else {
                $p = $r;
            }
        }
        my $s = $#smoothedScores;
        $s-- until $smoothedScores[$s] >= $cutoff;
        print {$to} join( "\t",
            $chr,
            $binsize * $p,
            $binsize * ($s + 1),
            $binsize * $p . "-" . $binsize * ($s + 1),
            $count,
            '.' ),
          "\n";
    }
    close $to;
}

sub _smoothVector {
    my ($ref, $window, $cutoff) = @_;
    my @t = @$ref;
    my (@totalNum, @peaks) = ($#t);
    my $ratio = 0;
    my @scores = @t;
    while ($ratio < $cutoff) {
        my @out = @t[0 .. $window/2-1];
        my @kept = @t[0 .. $window-1];
        my $sum = 0;
        $sum += $_ for @kept;
        shift @t for 1 .. $window;
        for (@t) {
            push @out, $sum / $window;
            $sum += $_ - $kept[0];
            shift @kept;
            push @kept, $_;
        }
        for (0 .. $window/2-1) {
            push @out, 0;
        }
        @peaks = _searchPeaks(@out);
        push @totalNum, $#peaks;
        $ratio = $totalNum[-1] / $totalNum[-2];
        if ($window % 2 == 0 and $#totalNum % 2 == 0) { # shift for even values
            shift @out;
            push @out, 0;
        }
        @t = @out;
    }
    return @t;
}

sub _searchExactPeaks {
    my @scores = @{$_[0]};
    my @peaks = @{$_[1]};
    my $p1 = shift @peaks;
    my @valleys;
    for my $p2 (@peaks) {
        my @s = @scores[$p1 .. $p2];
        my ($min, $site) = ($s[0], 0);
        for (0 .. $#s) {
            if ($s[$_] > $min) {
                $min = $s[$_];
                $site = $_;
            }
        }
        push @valleys, $site + $p1;
        $p1 = $p2;
    }
    return @valleys;
}

sub _searchExactValleys {
    my @scores = @{$_[0]};
    my @peaks = @{$_[1]};
    my $p1 = shift @peaks;
    my @valleys;
    for my $p2 (@peaks) {
        my @s = @scores[$p1 .. $p2];
        my ($min, $site) = ($s[0], 0);
        for (0 .. $#s) {
            if ($s[$_] < $min) {
                $min = $s[$_];
                $site = $_;
            }
        }
        push @valleys, $site + $p1;
        $p1 = $p2;
    }
    return @valleys;
}

sub _searchPeaks {
    my $score = $_[0];
    my $flag = 0;
    my (@out, $site);
    for my $i (0 .. $#_) {
        if ($_[$i] > $score) {
            $score = $_[$i];
            $site = $i;
            $flag = 1;
        }
        elsif ($_[$i] < $score) {
            if ($flag) {
                push @out, $site;
            }
            $score = $_[$i];
            $flag = 0;
        }
    }
    return @out;
}

sub _searchValleys {
    my $score = $_[0];
    my $flag = 0;
    my (@out, $site);
    for my $i (0 .. $#_) {
        if ($_[$i] < $score) {
            $score = $_[$i];
            $site = $i;
            $flag = 1;
        }
        elsif ($_[$i] > $score) {
            if ($flag) {
                push @out, $site;
            }
            $score = $_[$i];
            $flag = 0;
        }
    }
    return @out;
}



#############################################################################
#############################################################################
#####                   Documents defined here
#############################################################################
#############################################################################
sub _printUsage {
die <<EOF;
hicMapTools         Tool ultilities for HiC data analysis.
                    hicMapTools provides all functions integrated in hicMap,
                    hence you can do HiC data analysis step by step. Also,
                    hicMapTools contains many other useful functions for
                    further analysis and format transfermation.

Functions:
mapping                 Iteratively map raw HiC reads to genome.
pairing                 Pair mapped reads to get paired PETs.
splitAndRemoveDup       Split paired PETs into chrs and remove redundant PETs.
makeREfragments         Generate genome-wide RE fragments.
mapPETsToFragments      Filter invalid PETs using RE fragments.
supportedEnzymes        Show all the supported enzymes for RE fragments filtering.
removeShortLigation     Filter short-ligated PETs.
makeGenomicMatrix       Make genome-wide interaction matrix in ICE format.
ICEnorm                 Do ICE normalization.
genomicMatrixToWashU    Convert ICE format genomic interaction matrix to
                        WashU browser long-range interactions format.
petsToWashU             Convert intra PETs into WashU browser long-range
                        interactions format by generating the matrix.
chrPetsToWashU          Convert intra PETs into WashU browser long-range
                        interactions format by generating the matrix for given chr.
makeIntraMatrix         Generate intra interaction matrix for each chr.
makeInterMatrix         Generate inter interaction matrix for each chr.
calcIntraMatrixPCC      Calculate PCC for intra interaction matrix for each chr.
callInteractions        Call intra-interactions.
annotateInteractions    Annotate called intra-interactions to genes.
parseAnnotate           Parse annotation result from merged cluster format to
                        single cluster format.
getInteractedGenes      Get all interacted genes.
selectInteractions      Select interaction related to given genes.
interactionsToWashU     Convert intra-interactions to WashU interactions format.
intraTxtToBed           Convert 7 column TXT format intra-interactions to BED12
                        format.
compartment             Calculate A|B compartments.
pcatobedgraph           Convert PCA results from 'compartment' into bedGraph format.
checkABcompartments     Check and correct A|B compartment symbols.
diffCompartments        Compare compartments between samples.
calcDomainIndexes       Calculate directional indexes for intra interactions.
callDIdomains           Call TADs from directional indexes (DI) file.
calcInsulationScores    Calculate insulation scores from intra matrix file.
callInsulationTADs      Call TADs using insulation scores.
insulationMatrix        Convert intra matrix files into Cworld Dekker format
                        matrix, in order to calculate insulation scores using Cworld
                        Dekker scripts in https://github.com/dekkerlab/cworld-dekker.

Options:
-help, -h           If no function is specified, show this help information and
                    exit, else show the detailed help information for the given
                    function.

Note:
Function names are case-insensitive, short starting words which can distinguish
the specified function from others is enough, for example:
hicMapTools pa -h
is same as:
hicMapTools pairing -h

EOF
}

sub mapping_docs {
die <<EOF;
mapping:        This function iteratively maps raw HiC reads to reference.

Options:
-fq             [str]   Raw HiC reads directory. Paired reads should be put
                        under this directory (file name format:
                        *[_-]1.f(ast)q(.gz) or [_.]R1.f(ast)q(.gz), which
                        _1|-1 or _R1|.R1 indicates R1, .f(ast)q means .fq or
                        .fastq, (.gz) means end in .gz or not, this is the
                        general format generate by sequencer).
-genome, -g     [str]   Genome reference ID, such as hg19, mm9. Shell variable
                        \$BOWTIE_INDEXES should be set properly, you'd better
                        put -genome.fa and -genome.chromSizes under
                        \$BOWTIE_INDEXES.
-output, -o     [str]   Output directory.
-cpu, -c        [int]   CPUs number. Default is 20.
-mismatch, -mm  [int]   Maximum mismatches allowed for mapping. Default is 1.
-taglen, -tl    [int]   Tag length for iterative mapping. Default is 40.
-lenstep, -ls   [int]   Length step for iterative mapping to shift to 3' end
                        for unmapped and multiple mapped reads. Default is 10.
-trim5, -5      [int]   Trim 5' length before mapping. Default is 0.
-trim3, -3      [int]   Trim 3' length before mapping. Default is 0.
-help, -h               Show this help information and exit.

Note:
Output files will be placed under -output/map.

EOF
}

sub pairing_docs {
die <<EOF;
pairing:        This function pairs the mapped tags to get paired PETs.

Options:
-output, -o     [str]   The HiC output directory of 'mapping'.
-genome, -g     [str]   Genome reference ID, such as hg19, mm9. Shell variable
                        \$BOWTIE_INDEXES should be set properly, you'd better
                        put -genome.fa and -genome.chromSizes under
                        \$BOWTIE_INDEXES.
-cpu, -c        [int]   CPUs number. Default is 20.
-help, -h               Show this help information and exit.

EOF
}

sub splitAndRemoveDup_docs {
die <<EOF;
splitAndRemoveDup:      This function splits the paired PETs into chrs and
                        remove duplicated PETs.

Options:
-output, -o     [str]   The HiC output directory of 'mapping'.
-genome, -g     [str]   Genome reference ID, such as hg19, mm9. Shell variable
                        \$BOWTIE_INDEXES should be set properly, you'd better
                        put -genome.fa and -genome.chromSizes under
                        \$BOWTIE_INDEXES.
-cpu, -c        [int]   CPUs number. Default is 20.
-maxlines, -ml  [int]   Maximum lines to read in during processing. This is
                        used to control memory usage with parallel processing,
                        if run out of memory, please decrease this value or
                        -cpu. 1000000 lines costs about 500M memory, so total
                        memory in peak is multiplied by -cpu. Default is 1000000.
-help, -h               Show this help information and exit.

Note:
Output files will be placed under -output/map.

EOF
}

sub supportedEnzymes_docs {
die <<EOF;
supportedEnzymes:       This function prints all currently supported enzyme names.
                        Currently about 310 enzymes supported. Also, you can add
                        your own enzyme information if not included yet.

Options:
-help, -h               Show this help information and exit.

EOF
}

sub makeREfragments_docs {
die <<EOF;
makeREfragments:        This function generate genome-wide RE fragments for
                        specified enzyme.

Options:
-genome, -g     [str]   Genome reference ID, such as hg19, mm9. Shell variable
                        \$BOWTIE_INDEXES should be set properly, you'd better
                        put -genome.fa and -genome.chromSizes under
                        \$BOWTIE_INDEXES.
-enzyme, -ez    [str]   Enzyme name used in generating HiC library.
-fragments, -fm [str]   Output RE fragments file. Default is
                        '-enzyme.-genome.fragments.bed'.

EOF
}

sub mapPETsToFragments_docs {
die <<EOF;
mapPETsToFragments:     This function filters invalid PETs using RE fragments.
                        Only PETs which both sides mapped to RE cutting sites
                        within -distance are kept.

Options:
-output, -o     [str]   The HiC output directory of 'mapping'.
-genome, -g     [str]   Genome reference ID, such as hg19, mm9. Shell variable
                        \$BOWTIE_INDEXES should be set properly, you'd better
                        put -genome.fa and -genome.chromSizes under
                        \$BOWTIE_INDEXES.
-cpu, -c        [int]   CPUs number. Default is 20.
-enzyme, -ez    [str]   Enzyme name used in generating HiC library, optional.
-fragments, -fm [str]   RE fragments file for -enzyme. If only -enzyme is given,
                        this file will be generated automatically.
-distance, -di  [int]   Maximum distance to RE fragments ends. Default is 500.
-help, -h               Show this help information and exit.

Note:
Output files will be placed under -output/pets.

EOF
}

sub removeShortLigation_docs {
die <<EOF;
removeShortLigation:    This function filters short-ligated PETs.

Options:
-output, -o     [str]   The HiC output directory of 'mapping'.
-genome, -g     [str]   Genome reference ID, such as hg19, mm9. Shell variable
                        \$BOWTIE_INDEXES should be set properly, you'd better
                        put -genome.fa and -genome.chromSizes under
                        \$BOWTIE_INDEXES.
-cpu, -c        [int]   CPUs number. Default is 20.
-selflen, -sl   [int]   Minimal ligation distance. Default is 500.
-help, -h               Show this help information and exit.

Note:
Output files will be placed under -output/pets.

EOF
}

sub makeGenomicMatrix_docs {
die <<EOF;
makeGenomicMatrix:      This function generates genome-wide interaction matrix
                        for ICE normalization.
                        It will generate a .matrix file and a .bed file to show
                        the genomic bins.

Options:
-output, -o     [str]   The HiC output directory of 'mapping'.
-genome, -g     [str]   Genome reference ID, such as hg19, mm9. Shell variable
                        \$BOWTIE_INDEXES should be set properly, you'd better
                        put -genome.fa and -genome.chromSizes under
                        \$BOWTIE_INDEXES.
-binsize, -bs   [int]   Genomic bin size. Default is 20000.
-rawmatrix, -rm [str]   Output genome-wide interaction matrix file name.
                        Default is "genomeBins.*kb.matrix", while * is
                        -binsize / 1000.
-cpu, -c        [int]   CPUs number. Default is 20.
-help, -h               Show this help information and exit.

Note:
Output files will be placed under -output/pets.

EOF
}

sub ICEnorm_docs {
die <<EOF;
ICEnorm:            This function does the ICE normalization for genome-wide
                    interaction matrix. You should have ice properly installed
                    in your shell \$PATH.

Options:
-output, -o     [str]   The HiC output directory of 'mapping'.
-rawmatrix, -rm [str]   Raw interaction matrix file name, no directory needed.
-icematrix, -im [str]   ICE normalized matrix file name.
-eps            [float] --eps for ice. Default is 0.1.
-lowpec, -lp    [float] --filter_low_counts_perc for ice. Default is 0.02.
-highpec, -hp   [float] --filter_high_counts_perc for ice. Default is 0.
-maxiter, -mi   [int]   --max_iter for ice. Default is 100.
-dense          []      --dense for ice. Default is not set.
-help, -h               Show this help information and exit.

Note:
Output files will be placed under -output/pets.

EOF
}

sub genomicMatrixToWashU_docs {
die <<EOF;
genomicMatrixToWashU:   This function converts ICE format genomic interaction
                        matrix into WashU EpiGenome Browser long-range format.

Options:
-rawmatrix, -rm [str]   Raw interaction matrix file name.
-regionbed, -rb [str]   Interaction regions BED file name, this file is
                        generated by 'makeGenomicMatrix'.
-maxdistance, -md [int] Convert the interactions shorter than this distance
                        cutoff to final result. Default is 3000000 bp. Using
                        0 to output all interactions including inter-chrs.
-counts         [int]   Scale the total PETs counts to this value. Default is
                        10_000_000.
-output, -o     [str]   Output WashU file name. If -bgzip is set, this
                        should be a BED file, else a TXT file.
-bgzip, -bz     []      If set, output result in Track file format, you
                        need bgzip, tabix and bedSort (bedtools) properly
                        installed, else, output result in upload format.
                        Details can be seen in Wubrowse wiki pages.

EOF
}

sub calcDomainIndexes_docs {
die <<EOF;
calcDomainIndexes:      This function calculate directional indexes (DI) for
                        whole genome.
                        Note this function should be run under the -output/pets.

Options:
-genome, -g       [str] Genome reference, such as mm9, hg19.
-binsize, -bs     [int] Genome bin size. Default is 20000.
-maxDistance, -md [int] Maximal distance to count PETs. Default is 2000000.
-output, -o       [str] Output domain indexes file in bedGraph format.
-cpu, -c          [int] CPU number. Default is 20.

EOF
}

sub calcDomainIndexes_docs_unused {
die <<EOF;
calcDomainIndexes:      This function calculate directional indexes (DI) for
                        whole genome.
                        Note this function should be run under the -output
                        of 'makeIntraMatrix'.

Options:
-genome, -g       [str] Genome reference, such as mm9, hg19.
-binsize, -bs     [int] Genome bin size. Default is 20000.
-maxDistance, -md [int] Maximal distance to count PETs. Default is 2000000.
-output, -o       [str] Output domain indexes file in bedGraph format.
-cpu, -c          [int] CPU number. Default is 20.

EOF
}

sub petsToWashU_docs {
die <<EOF;
petsToWashU:        This function converts intra PETs into WashU EpiGenome
                    Browser long-range format by counting interaction
                    frequencies for each genomic bin.
                    Note this function should be run under the directory
                    of 'pets'.

Options:
-genome, -g       [str] Genome reference, such as mm9, hg19.
-binSize, -bs     [int] Bin size to calculate domain indexes. Default is 20000.
-maxDistance, -md [int] Maximal distance to count PETs. 0 for whole chromosome
                        wide. Default is 2000000.
-background, -bg  [int] Background count level. Only frequencies greater than
                        this cutoff will be outputted. Default is 1.
-output, -o       [str] Output interaction matrix in txt format. This file then
                        will be zipped using bgzip and indexed by tabix, which
                        then can be viewed in Wash U Epigenome Browser.

EOF
}

sub chrPetsToWashU_docs {
die <<EOF;
chrPetsToWashU      This function converts intra PETs into WashU EpiGenome
                    Browser long-range format by counting interaction
                    frequencies for each genomic bin for given chr.
                    Note this function should be run under the directory
                    of 'pets'.

Options:
-chr              [str] Chr ID, such as chr1, chrX.
-genome, -g       [str] Genome reference, such as mm9, hg19.
-binSize, -bs     [int] Bin size to calculate domain indexes. Default is 20000.
-maxDistance, -md [int] Maximal distance to count PETs. 0 for whole chromosome
                        wide. Default is 2000000.
-output, -o       [str] Output interaction matrix in txt format. This file then
                        will be zipped using bgzip and indexed by tabix, which
                        then can be viewed in Wash U Epigenome Browser.

EOF
}

sub makeIntraMatrix_docs {
die <<EOF;
makeIntraMatrix:    This function generates intra-interactional matrix by
                    counting interaction frequencies for each genomic bin for
                    each chromosome. The output is a symmetric matrix with
                    head line and first column as coordinates, while diagonals
                    are zeros.
                    Note this function should be run under the directory
                    of 'pets'.

Options:
-genome, -g    [str] Genome reference, such as mm9, hg19.
-binSize, -bs  [int] Bin size to calculate domain indexes. Default is 20000.
-output, -o    [str] Output directory. Each chr will generate a symmetrical
                     matrix file under this directory.
-cpu, -c       [int] CPU number. Default is 20.

EOF
}

sub makeInterMatrix_docs {
die <<EOF;
makeInterMatrix:    This function generates inter-interactional matrix by
                    counting interaction frequencies for each genomic bin for
                    each chromosome.
                    Note this function should be run under the directory
                    of 'pets'.

Options:
-genome, -g    [str] Genome reference, such as mm9, hg19.
-binSize, -bs  [int] Bin size to calculate domain indexes. Default is 20000.
-output, -o    [str] Output directory. Each chr will generate a symmetrical
                     matrix file verse each another chr under this directory.
-cpu, -c       [int] CPU number. Default is 20.

EOF
}

sub calcIntraMatrixPCC_docs {
die <<EOF;
calcIntraMatrixPCC:     This function calculate the PCC between intra interaction
                        matrix generated by 'makeGenomicMatrix'. The PCC will be
                        calculated for each chr between two HiC samples.

Options:
-genome, -g    [str] Genome reference, such as mm9, hg19.
-d1            [str] The HiC -output/pets directory of sample 1.
-d2            [str] The HiC -output/pets directory of sample 2.
-output, -o    [str] Output txt file name. PCC for each chr will be outputed
                     in each line with chr name.
-cutoff, -co   [float]  Cutoff to remove noise, interaction frenquencies less
                        than it will be removed for speeding. Default is 2.
EOF
}

sub callInteractions_docs {
die <<EOF;
callInteractions:       This function calls the long-range interactions based
                        on PETs density by clustering nearby PETs.
                        Note this function should be run under HIC-OUTPUT/pets
                        directory.

Options:
-genome, -g    [str] Genome reference, such as mm9, hg19.
-output, -o    [str] Output BED12 file name.
-distance, -di [int] Distance cutoff to filter out short PETs. Default is 10000.
-minpts, -mp   [int] Minimal PETs number to define an interaction. Default is 3.
-regionsize, -rs
               [int] Region size to cluster nearby PETs. Default is 1000.
-cpu, -c       [int] CPU number. Default is 20.

EOF
}

sub pcatobedgraph_docs {
    die <<EOF
Function pcatobedgraph     Convert PCA component into bedGraph format.
                           Note this function should be run under the -output
                           of 'makeIntraMatrix'.

Options:
-output, -o   [str]  Output bedGraph file name.
-genome, -g   [str]  Genome reference, such as mm9, hg19. If -genome is given,
                     then -chr will be ignored and all chrs will use the same
                     -pc.
-chr          [str]  Chromsomal indentity for input file, such as chr1.
-pc           [int]  Which PCA compartment. Should be one of 1, 2 or 3, stand for
                     PC1, PC2 or PC3. Default is 1.

EOF
}

sub compartment_docs {
    die <<EOF
Function compartment       Call A/B compartments for intra-chromosomal matrix.
                           This function takes the result of 'MakentraMatrix'
                           as input, and will calculate observed/expected ratio
                           and PCC, then do PCA analysis with the PCC matrix
                           using prcomp in R. It will output three files for
                           each chr: observed/expected ratio(*.oeratio),
                           PCC(*.cor) and PCA result(*.pca) with the first
                           three components.
                           Note this function should be run under the -output
                           of 'makeIntraMatrix'.

Options:
-genome, -g    [str] Genome reference, such as mm9, hg19.

EOF
}

sub diffCompartments_docs {
die <<EOF;
diffCompartments:       This function searches the differential compartments
                        regions between two samples.

Options:
-sample1, -s1    [str]  Compartment file 1.
-sample2, -s2    [str]  Compartment file 2.
-windowsize, -ws [int]  Minimal window size for differential regions. Default
                        is 20.
-gapsize, -gs    [int]  Maximal gap size for connecting regions. Default is 5.
-factor          [int]  Factor to define background noise value. Background
                        noise is defined as mean of absolute values divided by
                        this factor for each chromosome. Default is 3.
-foldchange, -fc [int]  Foldchange to define differential bins if they are in
                        the same state. Default is 2.
-output, -o      [str]  Output BED file for differential regions.

EOF
}

sub callDIdomains_docs {
die <<EOF;
callDIdomains           Call TADs from directional indexes (DI).
                        Note this command is the same as shell command
                        callHiCdomains.

Options:
-input, -i     [str]   Input DI file in bedGraph format.
-genome, -g    [str]   Genome reference, such as mm9, hg19.
-output, -o    [str]   Output TADs file in BED format.
-cpu, -c       [int]   CPUs. Default is 10. No more than it because Matlab may fail.

EOF
}

sub insulationMatrix_docs {
die <<EOF;
insulationMatrix        Convert intramatrix file into cworld dekker format
                        matrix in order to calculate insulation and TADs.
                        Note this command should be run under the -output
                        of function makeIntraMatrix.

Options:
-genome, -g [str]   Genome reference, such as mm9, hg19.
-output, -o [str]   Output directory.

EOF
}

sub checkABcompartments_docs {
die <<EOF;
checkABcompartments     Check and correct the A|B compartment value symbols to
                        make sure positive is A compartment and negative is B.
                        This command uses genes TSS sites to distinguigh A|B
                        regions, assuming TSSs are enriched in A compartment.

Options:
-input, -i  [str]   Compartment file in bedGraph format. This file will be
                    replaced after correction the A|B compartment symbols.
-genome, -g [str]   Genome reference, such as mm9, hg19. Gene annotation file
                    \$genome.knownGene.bed will be searched under directory
                    \$ENV{\$genome}.

EOF
}

sub annotateInteractions_docs {
die <<EOF;
annotateInteractions    Annotate the intra- and/or inter-chromosomal
                        interactions to reference genes. The interaction
                        regions are overlapped to promoter regions defined
                        as [TSS - upstream, TSS + downstream], if the
                        overlapped region satisfy either -ratio or -length,
                        then this interaction region is defined as Promoter,
                        else, Enhancer.

Options:
-intra          [str]   Intra-chromosomal interactions file. BED12 format.
-inter          [str]   Inter-chromosomal interactions file. TXT format.
                        At least one of -intra and -inter is needed. You can
                        give both.
-gene, -ge      [str]   Gene annotation file in BED13 format. You can set gene
                        name in 13th column. otherwise, will use transcript id
                        (in 4th column) in the output result.
-upstream, -us  [int]   TSS upstream to define promoter region. Default is 5000.
-downstream, -ds
                [int]   TSS downstream to define promoter region. Default is 5000.
-ratio, -rt     [float] Minimal overlap ratio cutoff to define a region is
                        promoter. Default is 0.5.
-length, -lt    [int]   Minimal overlap length cutoff to define a region is
                        promoter. Default is 1000.
-output, -o     [str]   Output file name.
-single, -sg    []      If set, annotate each interaction and output separately,
                        else, merge overlapped interaction regions before
                        annotating and output in a merged cluster format.

EOF
}

sub parseAnnotate_docs {
die <<EOF;
parseAnnotate       Parse annotateInteractions result to convert the merged
                    cluster format into single cluster format.

Options:
-input, -i  [str]   Function 'annotateInteractions' output without -single.
-output, -o [str]   Parsed annotation output in -single format.
EOF
}

sub getInteractedGenes_docs {
die <<EOF;
getInteractedGenes      Get all interacted genes. Each gene will be classified
                        as either 'promoter' or 'enhancer' interacted.

Options:
-input, -i          [str]   Input annotation result file.
-output, -o         [str]   Output file.
-single             []      Annotation is in single cluster format or merged
                            cluster format, see in 'annotateInteractions'.

EOF
}

sub selectInteractions_docs {
die <<EOF;
selectInteractions:    Select interactions related to given genes.

Options:
-gene, -g       [str]   Gene list. Can be a file whose first column is gene name
                        or a value which contains genes separated by comma.
-annotation, -n [str]   Interaction annotation file.
-type           [str]   Determine to select intra- or inter-chromosomal
                        interactions or both of them. Must be one of 'intra',
                        'inter' or 'all'. Default is 'intra'.
-merge, -mg     []      Determine whether to merge the output for all genes or
                        output them separately for each gene. Default is not set.
-output, -o     [str]   If -merge is set, -output is the output file name,
                        otherwise, it is the prefix for each gene's output file,
                        these output files will be in the format
                        "output.gene_name.bed".

EOF
}

sub interactionsToWashU_docs {
die <<EOF;
interactionsToWashU    Convert intra-interactions into Wash U Epigenome
                       Browser long-range bgzipped format.

Options:
-intra      [str]     Intra interactions in BED12 format.
-output, -o [str]     Output txt file.

EOF
}

sub intraTxtToBed_docs  {
die <<EOF;
intraTxtToBed       Convert TXT format intra-interactions into BED12 format.

Options:
-intra      [str]     Intra interactions in TXT format (7 columns).
-output, -o [str]     Output BED file.

EOF
}

sub calcInsulationScores_docs {
die <<EOF;
calcInsulationScores    Calculate insulation scores from intra-interaction
                        matrix.  Note this command should be run under the
                        -output of 'makeIntraMatrix'.

Options:
-genome, -g [str]       Genome reference, such as mm9, hg19.
-output, -o [str]       Output bedGraph file for insulation scores.
-windowsize, -ws [int]  Window size (or number of bins) used for calculating
                        insulation score. Default is 20.
-cpu, -c    [int]       CPUs. Default is 20.
-bgzip, -bz []          If set, bgzip and tabix the output file.
EOF
}

sub callInsulationTADs_docs {
die <<EOF;
callInsulationTADs      Call TADs from insulation scores.

Options:
-input, -i  [str]       Input insulation score bedGraph file generated by
                        'calcInsulationScores'. Can be gzipped. A smoothed
                        insulation score bedGraph file will be generated.
-genome, -g [str]       Genome reference, such as mm9, hg19.
-output, -o [str]       Output TADs file name in bed format.
-windowsize, -ws [int]  Window size to smooth the insulation scores. Smaller
                        window size can find more subTADs. Default is 3.
-boundarySize   [int]   Boundary size for estmating boundary cutoff. Bigger
                        size will generate broader boundaries. Default is 5.
-bgzip, -bz []          If set, bgzip and tabix the output files.
EOF
}


